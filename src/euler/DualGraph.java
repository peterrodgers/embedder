package euler;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.util.*;
import pjr.graph.*;
import euler.comparators.*;
import euler.display.*;
import euler.drawers.*;
import euler.utilities.*;


public class DualGraph extends Graph implements Cloneable {

	public static final NodeType POLY_NODE_TYPE = new NodeType("polyNode",1,1,"Rectangle",true);
	public static final EdgeType POLY_EDGE_TYPE = new EdgeType("polyEdge");

	public static Random random = new Random(System.currentTimeMillis());
	protected static EdgeType directedEdge = new EdgeType("directed",true);
	protected static EdgeType undirectedEdge = new EdgeType("undirected",false);
	
	protected static long NONWELLFORMED_TIME_LIMIT =3000;

	/** This list is generated by the triangulation method */
	protected ArrayList<TriangulationFace> triangulationFaces = new ArrayList<TriangulationFace>();
	/** list of edges which are removable, i.e, the removal of an edge in the list does not change the connectivity of the graph*/
	protected ArrayList<Edge> removableEdges = new ArrayList<Edge>();
	/** list of edges which are not removable, i.e, the removal of an edge in the list changes the connectivity of the graph*/
	protected ArrayList<Edge> unremovableEdges = new ArrayList<Edge>();	
	/** If contour labels have to be changed because of disconnected components, then this indicates the mapping */
	protected HashMap<String,String> contourDuplicateLabelMap = null;
	/** If holes appear in contour, then this indicates which contours have holes. The holes are given as a new contour label. */
	protected HashMap<String,String> contourHoleLabelMap = null;
	protected long timeLimit = 1000;

	
	public static void main(String[] args) {

/*		DualGraph dg = new DualGraph(new AbstractDiagram("0 ab ac"));
		Node empty = dg.firstNodeWithLabel("");
		Node ab = dg.firstNodeWithLabel("ab");
		Node ac = dg.firstNodeWithLabel("ac");
		dg.addEdge(new Edge(empty,ab));
		dg.addEdge(new Edge(empty,ac));
		dg.addEdge(new Edge(ab,ac));
*/	 
		
		// This has three faces, large outer face splits along  between 0 and a 
//		DualGraph dg = new DualGraph(new AbstractDiagram("0 a b c ab ac"));
/*
		// This has two faces, both split along ab between cd and abcd 
		DualGraph dg = new DualGraph(new AbstractDiagram("0 cd cdef abcdef abcd abd a"));
		dg.removeEdges(new ArrayList<Edge>(dg.getEdges()));
		dg.addEdge(new Edge(dg.firstNodeWithLabel(""),dg.firstNodeWithLabel("cd")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("cd"),dg.firstNodeWithLabel("cdef")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("cdef"),dg.firstNodeWithLabel("abcdef")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("abcdef"),dg.firstNodeWithLabel("abcd")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("abcd"),dg.firstNodeWithLabel("abd")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("abd"),dg.firstNodeWithLabel("a")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("a"),dg.firstNodeWithLabel("")));
*/
		// This has two faces, both split along def between ae and adf and split along d between a and ad
/*
		DualGraph dg = new DualGraph(new AbstractDiagram("0 a ae abce abcdf adf ad d"));
		dg.removeEdges(new ArrayList<Edge>(dg.getEdges()));
		dg.addEdge(new Edge(dg.firstNodeWithLabel(""),dg.firstNodeWithLabel("a")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("a"),dg.firstNodeWithLabel("ae")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("ae"),dg.firstNodeWithLabel("abce")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("abce"),dg.firstNodeWithLabel("abcdf")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("abcdf"),dg.firstNodeWithLabel("adf")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("adf"),dg.firstNodeWithLabel("ad")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("ad"),dg.firstNodeWithLabel("d")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("d"),dg.firstNodeWithLabel("")));
*/

		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b ac bc"));
		//dg.addEdge(new Edge(dg.firstNodeWithLabel("ac"),dg.firstNodeWithLabel("bc")));
/*		
		// The minimal concurrency problem
		DualGraph dg = new DualGraph(new AbstractDiagram("0 a ab bc c"));
		dg.removeEdges(new ArrayList<Edge>(dg.getEdges()));
		dg.addEdge(new Edge(dg.firstNodeWithLabel(""),dg.firstNodeWithLabel("a")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("a"),dg.firstNodeWithLabel("ab")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("ab"),dg.firstNodeWithLabel("bc")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("bc"),dg.firstNodeWithLabel("c")));
		dg.addEdge(new Edge(dg.firstNodeWithLabel("c"),dg.firstNodeWithLabel("")));
*/	
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b c ab ac bc"));

		
		//DualGraph dg = new DualGraph(new AbstractDiagram("a"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("a b ab"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a ab abc abcd abcde bcde bcd bc b"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a ab abc ac ad"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b d ab bd cd bcd"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b c ab ac bc"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b d f ab af cd de df cde cdf def cdef"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b ab ac abc"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b c d e ab ac ae bd be ce abe ace"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 b c d e f ab ad bc bf cd de df abc abf acd adf bcd bdf abcd abcf abdf acdf abcdf"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b c d e f g ae af bd bf cf cg df ef fg aef bdf cfg"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 b c d e f af bc bf cd ce cf abf acf bcf abcf"));
		
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 abc d e b c a ace bce ac ad	abce ce	bc ae be"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 d bd bcd abcd abd ab acd ac"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 c ab ac bc abc"));
		//DualGraph dg = new DualGraph(AbstractDiagram.VennFactory(1));
		//DualGraph dg = new DualGraph(AbstractDiagram.VennFactory(2));
		//DualGraph dg = new DualGraph(AbstractDiagram.VennFactory(3));
		//DualGraph dg = new DualGraph(AbstractDiagram.VennFactory(3));
		//DualGraph dg = new DualGraph(AbstractDiagram.randomDiagramFactory(5));
		//DualGraph dg = new DualGraph(AbstractDiagram.VennFactory(6));
		
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b c d e f ab ae af bf ce cf de df ef abf aef cdf cef def cdef"));
		//DualGraph dg = new DualGraph(new AbstractDiagram ("0 d abd e b c a bde de ac ad ab ce bd"));
		//DualGraph dg = new DualGraph(new AbstractDiagram ("0 d abd e b c a bde de ac ad ab ce bd"));
		//DualGraph dg = new DualGraph(new AbstractDiagram ("0 c ab ad bc bd cd abc bcd abcd"));
		//DualGraph dg = new DualGraph(new AbstractDiagram ("0 abc def ghi adg beh cfi"));
		//DualGraph dg = new DualGraph(new AbstractDiagram ("0 a b c ac bc"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b ab bc abc bcd abcd bcde bce bf f"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("0 a b c d f ab ac ad af"));
		//DualGraph dg = new DualGraph(new AbstractDiagram ("0 a ab abc bc bcd abcd acd ad d"));
		//DualGraph dg = new DualGraph(new AbstractDiagram ("0 a b c ac ab ad bc abc abd abcd"));
		DualGraph dg = new DualGraph(new AbstractDiagram ("0 a b c ac ab bc abc"));
		//DualGraph dg = new DualGraph(new AbstractDiagram("abcd defg aehi bfhk cgik")); //K5,5 example needing non-simple contours
		
		//dg.randomizeNodePoints(new Point(50,50),400,400);
		
		//System.out.println("empty node index " + emptyNodeIndex);
		// uncomment this to load a graph from a file
		// dg.loadAll(new File("C:\\code\\embedder\\trunk\\data\\buggyDiagrams\\holeInHole.txt"));
		//dg.loadAll(new File("c:\\code\\embedder\\trunk\\default.txt"));
		//dg.loadAll(new File("c:\\code\\embedder\\trunk\\contourRoutingBug2.txt"));
		//dg.loadAll(new File("c:\\code\\embedder\\trunk\\default.txt"));
		
		DualGraphWindow dw = new DualGraphWindow(dg);
		dw.getDiagramPanel().setShowGraph(true);
		dw.getDiagramPanel().setShowEdgeDirection(false);
		dw.getDiagramPanel().setShowEdgeLabel(true);
		dw.getDiagramPanel().setShowContour(false);
		dw.getDiagramPanel().setShowContourLabel(true);
		dw.getDiagramPanel().setShowTriangulation(false);
		dw.getDiagramPanel().setJiggleLabels(false);
		
		dw.getDiagramPanel().setForceNoRedraw(true);
		DiagramDrawerPlanar ddp = new DiagramDrawerPlanar(KeyEvent.VK_P, "Planar Layout Algorithm", KeyEvent.VK_P, dw.getDiagramPanel());
	 	ddp.layout();
		PlanarForceLayout pfl = new PlanarForceLayout(dw.getDiagramPanel());
		pfl.setAnimateFlag(false);
		pfl.setIterations(50);
		pfl.drawGraph();
		dw.getDiagramPanel().fitGraphInPanel();
		dw.getDiagramPanel().setForceNoRedraw(false);
		dw.getDiagramPanel().update(dw.getDiagramPanel().getGraphics());
		//dg.checkInductivePiercingDiagram();
	}
	
	
	/**
	 * Generate the AbstractGraph from the given AbstractDiagram.
	 */
	public DualGraph(AbstractDiagram ad) {
		generateAbstractGraph(ad);
		setLabel(ad.toString());
		directEdges();
		labelEdgesWithContours();	
	}	
		
	public DualGraph() {
		
	}
	
	
	public ArrayList<Edge> getRemovableEdges(){ return removableEdges; }
	public ArrayList<Edge> getUnremovableEdges(){ return unremovableEdges; }	
	public ArrayList<TriangulationFace> getTriangulationFaces() {return triangulationFaces;}
	public HashMap<String,String> getContourDuplicateLabelMap() {return contourDuplicateLabelMap;}
	public HashMap<String,String> getContourHoleLabelMap() {return contourHoleLabelMap;}
	
	public void setTriangulationFaces(ArrayList<TriangulationFace> inTFs) {triangulationFaces = inTFs;}
	public void setContourDuplicateLabelMap(HashMap<String,String> map) {contourDuplicateLabelMap = map;}
	public void setContourHoleLabelMap(HashMap<String,String> map) {contourHoleLabelMap = map;}

	public ArrayList<TriangulationEdge> findTriangulationEdges() {
		ArrayList<TriangulationEdge> ret = new ArrayList<TriangulationEdge>();
		for(TriangulationFace tf : triangulationFaces) {
			TriangulationEdge te;
			
			te = tf.getTE1();
			if(!ret.contains(te)) {
				ret.add(te);
			}
			
			te = tf.getTE2();
			if(!ret.contains(te)) {
				ret.add(te);
			}
			
			te = tf.getTE3();
			if(!ret.contains(te)) {
				ret.add(te);
			}
		}
		return ret;
	}

	
	/**
	 * Adds an triangulation edge to the graph.
	 * @return true if the node is added, false if it fails because the edge is
	 * already there, or either node is not in the graph.
	 */
	public boolean addTriangulationFace(Face face, TriangulationEdge te1, TriangulationEdge te2, TriangulationEdge te3) {
		TriangulationFace tf = new TriangulationFace(face,te1,te2,te3);
		
		return(triangulationFaces.add(tf));
	}
	
	/** Removes the TF from the graph */
	public boolean removeTriangulationFace(TriangulationFace removeFace) {
		if(!containsTriangulationFace(removeFace)) {
			return(false);
		}
		triangulationFaces.remove(removeFace);
		return(true);
	}
	

	/** Checks to see if the TF is in the graph */
	public boolean containsTriangulationFace(TriangulationFace tf) {
		for(TriangulationFace next : getTriangulationFaces()) {
			if(tf == next) {
				return(true);
			}
		}
		return(false);
	}
	
	

	/**
	 * Finds the AbstractDiagram on the fly, as
	 * editing or loading might change it.
	 * This also takes account of duplicate zones.
	 * @return the abstract diagram formed from the node labels in the graph
	 * discarding duplicates, or the empty diagram if there are no nodes in
	 * the graph.
	 */
	public AbstractDiagram findAbstractDiagram() {
		ArrayList<String> zoneList = new ArrayList<String>();
		for(Node n : getNodes()) {
			String label = n.getLabel();
			if(label.equals("")) {
				label = "0";
			}
			zoneList.add(label);
		}
		
		Collections.sort(zoneList);
		AbstractDiagram.removeDuplicatesFromSortedList(zoneList);

		StringBuffer zoneSB = new StringBuffer("");
		for(String s : zoneList) {
			zoneSB.append(s);
			zoneSB.append(" ");
		}
		
		AbstractDiagram ret = new AbstractDiagram(zoneSB.toString());
		
		return ret;
	}
	
	
	/**
	 * Generate a random dual by creating rectangles, then deriving their intersection.
	 */
	public static DualGraph randomDualGraphFactoryByRectangles(int numberOfContours, int padding, int diagramSize, boolean concreteDual) {

		ArrayList<ConcreteContour> concreteContours = new ArrayList<ConcreteContour>();
		
		for(int i = 0; i< numberOfContours;i++) {
			
			Polygon polygon = new Polygon();
			int area = 0;
			int x = 0;
			int y = 0;
			int width = 0;
			int height = 0;
			int minArea = (diagramSize/6) *(diagramSize/6);
			while(area < minArea) {
				x = padding+random.nextInt(diagramSize);
				y = padding+random.nextInt(diagramSize);
				width = random.nextInt((padding+diagramSize) - x);
				height = random.nextInt((padding+diagramSize) - y);
				area = width*height;
			}
			polygon.addPoint(x,y);
			polygon.addPoint(x+width,y);
			polygon.addPoint(x+width,y+height);
			polygon.addPoint(x,y+height);
			
			char label = (char)((int)'a'+i); 
			ConcreteContour cc = new ConcreteContour(Character.toString(label),polygon);
			concreteContours.add(cc);
			
		}
		
		HashMap<String,Area> zoneMap = ConcreteContour.generateZoneAreas(concreteContours);

		DualGraph dg = new DualGraph();
		
		factoryCreatedAreas = new ArrayList<Area>();
		
		// put the nodes in the middle of the polygon bounding boxes
		for(String zone : zoneMap.keySet()) {
			Area area = zoneMap.get(zone);
			Rectangle bounds = area.getBounds();
			Point centre = new Point((int)(bounds.getX()+bounds.getWidth()/2),(int)(bounds.getY()+bounds.getHeight()/2));
			if(zone.equals("")) {
				// dont want to put the empty zone in the middle of the diagram
				// so put it in the top left
				centre.x = padding;
				centre.y = padding;
			} else {
				factoryCreatedAreas.add(area);
			}

			while(dg.firstNodeAtPoint(centre) != null) { // if the node overlays another, just place it randomly
				centre = new Point(padding+random.nextInt(diagramSize),padding+random.nextInt(diagramSize));
			}
			Node n = new Node(zone,centre);
			dg.addNode(n);
		}
		
		createEdgesBetweenNodesWithOneLabelDifference(dg);
		
		// if a concreteDual is required then remove edges between
		// non adjacent edges
		// otherwise leave as the superdual
		if(concreteDual) {
			filterUnconnectedZones(dg,zoneMap);
		}

/*		
		try {
			boolean planar = DiagramDrawerPlanar.isPlanar(dg);
			if(!planar) {
				// try to remove an edge to gain planarity
				//DualGraph newDual = null;
				DualGraph newDual = dg.findWellformedPlanarGraph();
				if(newDual == null) {44
					System.out.println("can not find a wellformed planar graph after edge removing");
					BasicSpringEmbedder se = new BasicSpringEmbedder();
					se.setGraphPanel(new GraphPanel(dg, new Frame()));
					se.layout();
					newDual = findNonWellformedPlanarGraph(dg);
				}
				dg = newDual;
			}
		} catch(Exception e) {
			e.printStackTrace();
		
		}
*/		
		return dg;
	}
	
	/**
	 * Generate a random dual by creating rectangles, then deriving their intersection.
	 */
	public static DualGraph randomWellformedDualGraphFactoryByRectangles(int numberOfContours, int padding, int diagramSize, boolean concreteDual) {

		ArrayList<ConcreteContour> concreteContours = new ArrayList<ConcreteContour>();
		
		for(int i = 0; i< numberOfContours;i++) {
			
			Polygon polygon = new Polygon();
			int area = 0;
			int x = 0;
			int y = 0;
			int width = 0;
			int height = 0;
			int minArea = (diagramSize/6) *(diagramSize/6);
			while(area < minArea) {
				x = padding+random.nextInt(diagramSize);
				y = padding+random.nextInt(diagramSize);
				width = random.nextInt((padding+diagramSize) - x);
				height = random.nextInt((padding+diagramSize) - y);
				area = width*height;
			}
			polygon.addPoint(x,y);
			polygon.addPoint(x+width,y);
			polygon.addPoint(x+width,y+height);
			polygon.addPoint(x,y+height);
			
			char label = (char)((int)'a'+i); 
			ConcreteContour cc = new ConcreteContour(Character.toString(label),polygon);
			concreteContours.add(cc);
			
		}
		
		HashMap<String,Area> zoneMap = ConcreteContour.generateZoneAreas(concreteContours);

		DualGraph dg = new DualGraph();
		
		factoryCreatedAreas = new ArrayList<Area>();
		
		// put the nodes in the middle of the polygon bounding boxes
		for(String zone : zoneMap.keySet()) {
			Area area = zoneMap.get(zone);
			Rectangle bounds = area.getBounds();
			Point centre = new Point((int)(bounds.getX()+bounds.getWidth()/2),(int)(bounds.getY()+bounds.getHeight()/2));
			if(zone.equals("")) {
				// dont want to put the empty zone in the middle of the diagram
				// so put it in the top left
				centre.x = padding;
				centre.y = padding;
			} else {
				factoryCreatedAreas.add(area);
			}

			while(dg.firstNodeAtPoint(centre) != null) { // if the node overlays another, just place it randomly
				centre = new Point(padding+random.nextInt(diagramSize),padding+random.nextInt(diagramSize));
			}
			Node n = new Node(zone,centre);
			dg.addNode(n);
		}
		
		createEdgesBetweenNodesWithOneLabelDifference(dg);
		
		// if a concreteDual is required then remove edges between
		// non adjacent edges
		// otherwise leave as the superdual
		if(concreteDual) {
			filterUnconnectedZones(dg,zoneMap);
		}

/*		
		try {
			boolean planar = DiagramDrawerPlanar.isPlanar(dg);
			if(!planar) {
				// try to remove edges to gain planarity
				dg = dg.findWellformedPlanarGraph();
				
			}
			else{
			
			}
		} catch(Exception e) {
			e.printStackTrace();
		
		}
*/
		
		return dg;
	}
	
	
/** gives access to the areas used when creating new diagrams */
public static ArrayList<Area> factoryCreatedAreas = null;
	
	/**
	 * Generate a random dual by creating triangles, then deriving their intersection.
	 */
	public static DualGraph randomDualGraphFactoryByTriangles(int numberOfContours, int padding, int diagramSize, boolean concreteDual) {
		ArrayList<ConcreteContour> concreteContours = new ArrayList<ConcreteContour>();
		
		for(int i = 0; i< numberOfContours;i++) {
			
			Polygon polygon = new Polygon();
			Point p1 = new Point(padding+random.nextInt(diagramSize),padding+random.nextInt(diagramSize));
			// ensure connectedness by putting p1 inside the current contours
			final int fudgeStop = 1000; // in case current contours are too small for the point to hit them
			int count = 0;
			if(i !=0) {
				
				boolean inside = false;
				while(!inside) {
					if(count > fudgeStop) {
						break;
					}
					count++;
					for(ConcreteContour cc : concreteContours) {
						Polygon p = cc.getPolygon();
						if(p.contains(p1)) {
							inside = true;
							break;
						}
					}
					if(!inside) {
						p1 = new Point(padding+random.nextInt(diagramSize),padding+random.nextInt(diagramSize));
					}
				}
			}
			Point p2 = new Point(padding+random.nextInt(diagramSize),padding+random.nextInt(diagramSize));
			Point p3 = new Point(padding+random.nextInt(diagramSize),padding+random.nextInt(diagramSize));
			polygon.addPoint(p1.x, p1.y);
			polygon.addPoint(p2.x, p2.y);
			polygon.addPoint(p3.x, p3.y);
			char label = (char)((int)'a'+i); 
			
			ConcreteContour cc = new ConcreteContour(Character.toString(label),polygon);
			concreteContours.add(cc);
			
		}
		
		HashMap<String,Area> zoneMap = ConcreteContour.generateZoneAreas(concreteContours);

		DualGraph dg = new DualGraph();
		
		factoryCreatedAreas = new ArrayList<Area>();
		
		// put the nodes in the middle of the polygon bounding boxes
		for(String zone : zoneMap.keySet()) {
			Area area = zoneMap.get(zone);
			Rectangle bounds = area.getBounds();
			Point centre = new Point((int)(bounds.getX()+bounds.getWidth()/2),(int)(bounds.getY()+bounds.getHeight()/2));
			if(zone.equals("")) {
				// dont want to put the empty zone in the middle of the diagram
				// so put it in the top left
				centre.x = padding;
				centre.y = padding;
			} else {
				factoryCreatedAreas.add(area);
			}

			while(dg.firstNodeAtPoint(centre) != null) { // if the node overlays another, just place it randomly
				centre = new Point(padding+random.nextInt(diagramSize),padding+random.nextInt(diagramSize));
			}
			Node n = new Node(zone,centre);
			dg.addNode(n);
		}

		createEdgesBetweenNodesWithOneLabelDifference(dg);
		
		// if a concreteDual is required then remove edges between
		// non adjacent edges
		// otherwise leave as the superdual
		if(concreteDual) {
			filterUnconnectedZones(dg,zoneMap);
		}
		
		return dg;
	}
	

	/**
	 * Filter edges from the dg if the areas of the two zones
	 * represented by the nodes at either end are not connected.
	 */
	public static void filterUnconnectedZones(DualGraph dg, HashMap<String, Area> zoneMap) {
		
		Area allInnerAreas = new Area();
		for(String zone : zoneMap.keySet()) {
			if(!zone.equals("")) {
				Area area = zoneMap.get(zone);
				allInnerAreas.add(area);
			}
		}
		
		ArrayList<Edge> removeEdges = new ArrayList<Edge>();
		for(Edge e : dg.getEdges()) {
			
			String label1 = e.getFrom().getLabel();
			String label2 = e.getTo().getLabel();
			
			String diff = findLabelDifferences(label1,label2);
			if(diff.length() != 1) {
				// only check zones with one label difference
				continue;
			}
			
			Area a1 = zoneMap.get(label1);
			Area a2 = zoneMap.get(label2);
			
			Area outsideArea = null;
			Area insideArea = null;
			if(label1.equals("")) {
				outsideArea = allInnerAreas;
				insideArea = a2;
			}
			if(label2.equals("")) {
				outsideArea = allInnerAreas;
				insideArea = a1;
			}
			
			if(outsideArea == null) {
				// neither areas are the outside
				Area a = new Area(a1);
				a.add(a2);
				if(!a.isSingular()) {
					removeEdges.add(e);
				}
			} else {
				// one of the areas is the outside
				Area a = new Area(outsideArea);
				a.subtract(insideArea);
				if(!a.isSingular()) {
					removeEdges.add(e);
				}
/*if(label1.equals("a") || label2.equals("a")) {
	DualGraphWindow dgw = new DualGraphWindow(dg);
//	DiagramPanel.areas.add(outsideArea);
//	DiagramPanel.areas.add(insideArea);
	DiagramPanel.areas.add(a);
}
*/				
			}
		}
		
		for(Edge removeEdge : removeEdges) {
			dg.removeEdge(removeEdge);
		}
		
	}


	/**
	 * Compare each zone against each other, create a node for each zone
	 * and an edge between two zones where there is one contour difference
	 * between them.
	 */ 
	public void generateAbstractGraph(AbstractDiagram abstractDiagram) {
		
		ArrayList<String> zones = abstractDiagram.getZoneList();
		clear();
		// Generate the nodes
		for(String zone: zones) {
			Node n = new Node(zone);
			addNode(n);
		}
		
		createEdgesBetweenNodesWithOneLabelDifference(this);
	}
	
	
	/**
	 * Add the nodes to the dualGraph and then call this.
	 */
	public static void createEdgesBetweenNodesWithOneLabelDifference(DualGraph dg) {
		
		// compare all nodes against each other
		ArrayList<Node> nodes = dg.getNodes();
		for(int n1Index = 0; n1Index < nodes.size(); n1Index++) {
			for(int n2Index = n1Index+1; n2Index < nodes.size(); n2Index++) {
				Node n1 = nodes.get(n1Index);
				Node n2 = nodes.get(n2Index);
				int labelDifferences = countLabelDifferences(n1.getLabel(),n2.getLabel());
				if(labelDifferences == 1) {
					String label1 = n1.getLabel();
					String label2 = n2.getLabel();
					String diff = findLabelDifferences(label1, label2);			
					Edge e = new Edge(n1,n2,diff);
					dg.addEdge(e);
				}
			}
		}
	}
	
	
	/** 
	 * Labels the edges with the difference between the node labels.
	 * This is needed to work out which contours go through the edges
	 */
	public void labelEdgesWithContours() {
		
		for(Edge e : getEdges()){
			String label1 = e.getFrom().getLabel();
			String label2 = e.getTo().getLabel();
			String diff = findLabelDifferences(label1, label2);
			e.setLabel(diff);
		}
		
		for(TriangulationFace tf : getTriangulationFaces()){
			String label1,label2,diff;
			
			TriangulationEdge te1 = tf.getTE1();
			label1 = te1.getFrom().getLabel();
			label2 = te1.getTo().getLabel();
			diff = findLabelDifferences(label1, label2);
			te1.setLabel(diff);
			
			TriangulationEdge te2 = tf.getTE2();
			label1 = te2.getFrom().getLabel();
			label2 = te2.getTo().getLabel();
			diff = findLabelDifferences(label1, label2);
			te1.setLabel(diff);
			
			TriangulationEdge te3 = tf.getTE2();
			label1 = te3.getFrom().getLabel();
			label2 = te3.getTo().getLabel();
			diff = findLabelDifferences(label1, label2);
			te1.setLabel(diff);

		}
	}
	
	/**
	 * This sets the edge types to either directed or undirected. Directed
	 * edges are from a node with a label entirely contained in the other
	 * node label.
	 */ 
	public void directEdges() {
		
		Iterator<Edge> itr = getEdges().iterator();
		while(itr.hasNext()){
			Edge e = itr.next();
			
			Node from = e.getFrom();
			Node to = e.getTo();
			String labelFrom = from.getLabel();
			String labelTo = to.getLabel();
			boolean toInFrom = findLabelContainment(labelTo, labelFrom);
			if(toInFrom) {
				e.setType(directedEdge);
			} else {
				boolean fromInTo = findLabelContainment(labelFrom, labelTo);
				if(fromInTo) {  // directed but is currently facing the wrong way
					e.reverse();
					e.setType(directedEdge);
				} else {
					e.setType(undirectedEdge);
				}
			}
		}
	
	}
	
	
	/**
	 * Finds the total number of contour differences in the two labels.
	 * So that abc abd have a difference of 2, ab ab have 0 and abc ab have 1.
	 */
	public static int countLabelDifferences(String label1, String label2) {
		return findLabelDifferences(label1,label2).length();
	}
	
	
	/**
	 * Discovers if the first label is entirely contained in the other label.
	 */
	public static boolean findLabelContainment(String label1, String label2) {		
		if(label1.length() >= label2.length()) { // quick test to avoid later processing
			return false;
		}
		ArrayList<String> labelList1 = AbstractDiagram.findContourList(label1);
		ArrayList<String> labelList2 = AbstractDiagram.findContourList(label2);

		for(String contour1: labelList1) {
			if(!labelList2.contains(contour1)) {
				return false;
			}
		}

		return true;
	}
	
	
	/**
	 * Returns the difference in characters between the two labels, the
	 * returned String is ordered.
	 */
	public static String findLabelDifferences(String label1, String label2) {
		
		ArrayList<String> labelList1 = AbstractDiagram.findContourList(label1);
		ArrayList<String> labelList2 = AbstractDiagram.findContourList(label2);

		ArrayList<String> oldList1 = new ArrayList<String>(labelList1);
		for(String contour1: oldList1) {
			if(labelList2.contains(contour1)) {
				labelList1.remove(contour1);
				labelList2.remove(contour1);
			}
		}
		
		labelList1.addAll(labelList2);
		
		Collections.sort(labelList1);
		StringBuffer ret = new StringBuffer();
		for(String l: labelList1) {
			ret.append(l);
		}
		
		return ret.toString();
	}
	
	
	/**
	 * Returns the intersection in characters between the two labels, the
	 * returned String is ordered.
	 */
	public static String findLabelIntersection(String label1, String label2) {
		
		ArrayList<String> labelList1 = AbstractDiagram.findContourList(label1);
		ArrayList<String> labelList2 = AbstractDiagram.findContourList(label2);

		ArrayList<String> retList = new ArrayList<String>();
		
		for(String contour: labelList1) {
			if(labelList2.contains(contour)) {
				retList.add(contour);
			}
		}
		
		Collections.sort(retList);
		StringBuffer ret = new StringBuffer();
		for(String l: retList) {
			ret.append(l);
		}
		
		return ret.toString();
	}

	
	/**
	 * Checks the connectivity of the abstract graph 
	 * this includes two steps:
	 * 	1. check if the graph is connected
	 * 	2. for each contour, check if its inclusive sub graph is connected,
	 *     and its exclusive sub graph is connected.
	 * only when all the conditions are met, the connectivity condition pass 
	 **/
	public boolean checkConnectivity() {
		
		if (this.connected() == false)	{	
			//System.out.println("graph is not connected");
			return false;
		}
			
		else{
			ArrayList<String> contourList = findAbstractDiagram().getContours();		
			for(String s : contourList){			
				if(!checkConnectivity(s)){
					//System.out.println(s + " is not connected");
					return false;
				}
			}		
			return true;
		}
	}
	
	
	/**
	 * Checks the connectivity of the abstract graph with an edge removed from the graph
	 */
	public boolean checkConnectivity(Edge edgeToRemove){
		
		DualGraph temp = this.clone();
		int idx = -1;
		ArrayList<Edge> tempEdges = temp.getEdges();		
		for(int i = 0; i < tempEdges.size(); i++ ) {
			Edge e = tempEdges.get(i);
			if(e.equals(edgeToRemove))
				idx = i;
		}
		if(idx!=-1)
		temp.getEdges().remove(idx);
		
		if (! temp.connected()){
			return false;		
		}
		else{
			ArrayList<String> contourList = findAbstractDiagram().getContours();
			for(String s : contourList){
				if(! checkConnectivity( s, edgeToRemove)){
					return false;
				}
			}		
			return true;
		}
	}
	
	/**
	 * Checks the connectivity of the sub graph (based on an particular node)
	 * with an edge removed from the graph
	 */		
	public boolean checkConnectivity(String label, Edge removedEdge){
		
		DualGraph subgraphInc =  findSubgraphInc(label, removedEdge);		
		DualGraph subgraphExc =  findSubgraphExc(label, removedEdge);
		if(!subgraphInc.connected()||!subgraphExc.connected()){
			return false;
		} 
		else
			return true;		
	}
	
	/**
	 *Checks the connectivity of the sub graph (based on an particular node)
	 */
	public boolean checkConnectivity(String label){
		
		DualGraph subgraphInc = findSubgraphInc(label);		
		DualGraph subgraphExc = findSubgraphExc(label);		
		if(!subgraphInc.connected()||! subgraphExc.connected()){			
			return false;
		}
		else
			return true;		
	}
	
	/**
	 * Returns the inclusive sub graph based on node with particular label with an edge removed from the graph
	 **/	
	public DualGraph findSubgraphInc(String label, Edge edgeToRemove){
		
		DualGraph subgraphInc  = findSubgraphInc(label);
		int idx = -1;
		for(int i = 0; i < subgraphInc.getEdges().size(); i++ ) {
			Edge e = subgraphInc.getEdges().get(i);
			if(e.equals(edgeToRemove))
				idx = i;
		}
		if(idx!=-1)
		subgraphInc.getEdges().remove(idx);
		
		return subgraphInc;

	}
	
	/**
	 * Returns the exclusive sub graph based on node with particular label with an edge removed from the graph
	 **/	
	public DualGraph findSubgraphExc(String label, Edge edgeToRemove){		
		DualGraph subgraphExc  = findSubgraphExc(label);
		int idx = -1;
		for(int i = 0; i < subgraphExc.getEdges().size(); i++ ) {
			Edge e = subgraphExc.getEdges().get(i);
			if(e.equals(edgeToRemove))
				idx = i;
		}
		if(idx!=-1)
		subgraphExc.getEdges().remove(idx);
		
		return subgraphExc;
	}
	
	
	/**
	 * Returns a list of nodes that belongs to a inclusive sub graph 
	 * based on a particular node
	 **/	
	public ArrayList<Node> findSubgraphNodeInc(String label){
		
		ArrayList<Node> subgraphInc = new ArrayList<Node>();
		for(Node n :nodes){
			if(n.getLabel().contains(label))			
				subgraphInc.add(n);
		}	
		return subgraphInc;
	}
	
	
	/**
	 * Returns a list of nodes that belongs to a exclusive sub graph 
	 * based on a particular node
	 **/
	public ArrayList<Node> findSubgraphNodeExc(String label){
		
		ArrayList<Node> subgraphExc = new ArrayList<Node>();
		for(Node n : nodes){
			if(!n.getLabel().contains(label))			
				subgraphExc.add(n);
		}	
		return subgraphExc;
	}
	
	
	/**
	 * Returns the inclusive sub graph based on node with particular label 
	 **/
	public DualGraph findSubgraphInc(String label){
		
		DualGraph ret = this.clone();	
		for(Node n : getNodes()){
			if(!n.getLabel().contains(label)){
				ret.removeNode(n.getLabel());
			}
		}
		return ret;
	}
	
	/**
	 * Returns the exclusive sub graph based on node with particular label
	 **/
	public DualGraph findSubgraphExc(String label){
		
		DualGraph ret = this.clone();	
		for(Node n : getNodes()){
			if(n.getLabel().contains(label)){
				ret.removeNode(n.getLabel());
			}
		}
		return ret;
	}
	
	
	/**
	 * Returns lists of connnected nodes that contain the particular string 
	 **/
	public ArrayList<ArrayList<Node>> findConnectedSubgraphInc(String c) {
		
		ArrayList<ArrayList<Node>> ret = new ArrayList<ArrayList<Node>>();
		
		ArrayList<Node> incNodes = findSubgraphNodeInc(c);
		
		while(incNodes.size() != 0) {
			Node n = incNodes.get(0);
			ArrayList<Node> newSubGraph = findNodesConnectedToNode(n,incNodes);
			incNodes.removeAll(newSubGraph);
			ret.add(newSubGraph);
		}
		
		return ret;
		
	}
	
	
	/**
	 * Returns lists of connnected nodes that do not contain the particular string 
	 **/
	public ArrayList<ArrayList<Node>> findConnectedSubgraphExc(String c) {
		
		ArrayList<ArrayList<Node>> ret = new ArrayList<ArrayList<Node>>();
		
		ArrayList<Node> excNodes = findSubgraphNodeExc(c);
		
		while(excNodes.size() != 0) {
			Node n = excNodes.get(0);
			ArrayList<Node> newSubGraph = findNodesConnectedToNode(n,excNodes);
			excNodes.removeAll(newSubGraph);
			ret.add(newSubGraph);
		}
		
		return ret;
		
	}


	
	/**
	 * Find a sublist of nodeList that form a connected subgraph with n.
	 */
	public ArrayList<Node> findNodesConnectedToNode(Node n, ArrayList<Node> nodeList) {
		
		setNodesVisited(false);
		
		ArrayList<Node> ret = new ArrayList<Node>();
		
		if(!getNodes().contains(n)) {
			return ret;
		}
		
		ArrayList<Node> queue = new ArrayList<Node>();
		queue.add(n);
		ret.add(n);
		n.setVisited(true);
		while(!queue.isEmpty()) {

			Node head = queue.get(0);
			queue.remove(0);

			ArrayList<Node> neighbours = head.unvisitedConnectingNodes();
			ArrayList<Node> addNodes = new ArrayList<Node>();
			for(Node nextN : neighbours) {
				if(nodeList.contains(nextN)) {
					addNodes.add(nextN);
				}
			}
			setNodesVisited(neighbours,true);
			queue.addAll(addNodes);
			ret.addAll(addNodes);
		}
		
		return ret;

	}
	
	
	/**
	 * Changes the node labels so that disconnected components can
	 * be drawn. For duplicated contours this means a new label is
	 * added, the label differs between multiple disconnected components.
	 * For holes, both the outer contour label and a new label is added,
	 * again the label differs between multiple disconnected holes.
	 * The contour label maps are set with the new - old contour label pairs.
	 */
	public void renameDisconnectedContours() {
		contourDuplicateLabelMap = new HashMap<String,String>();
		contourHoleLabelMap = new HashMap<String,String>();
		
		ArrayList<String> contours = findAbstractDiagram().getContours();
				
		
		for(String c : contours) {
			ArrayList<ArrayList<Node>> incSubgraphs = findConnectedSubgraphInc(c);
			
			contourDuplicateLabelMap.put(c, c);
			for(int i = 1; i < incSubgraphs.size(); i++) { // dont change the label of the first one
				String newString = Character.toString(findNewChar(c.charAt(0)));
				for(Node n : incSubgraphs.get(i)) {
					ArrayList<String> labelList = AbstractDiagram.findContourList(n.getLabel());
					labelList.remove(c);
					labelList.add(newString);
					Collections.sort(labelList);
					
					// rebuild the label
					StringBuffer labelBuffer = new StringBuffer();
					for(String s: labelList) {
						labelBuffer.append(s);
					}
					n.setLabel(labelBuffer.toString());
				}
				contourDuplicateLabelMap.put(newString, c);
			}

			// TODO bug here, relabelling may cause hole in holes to
			// not be found, but moving this at the same time as
			// finding incSubgraphs causes knock on effects
			// bug found in holeInHole2.txt
			ArrayList<ArrayList<Node>> excSubgraphs = findConnectedSubgraphExc(c);
			
			for(ArrayList<Node> excList : excSubgraphs) {
				// dont do anything to a disconnected component with the outside zone
				boolean containsEmpty = false;
				for(Node n : excList) {
					if(n.getLabel().equals("")) {
						containsEmpty = true;
						break;
					}
				}
				if(containsEmpty) {
					continue;
				}
				
				// add the contour label plus new label
				String holeString = Character.toString(findNewChar(c.charAt(0)));
				for(Node n : excList) {
					ArrayList<String> labelList = AbstractDiagram.findContourList(n.getLabel());
					labelList.add(holeString);
					labelList.add(c);
					Collections.sort(labelList);
					
					// rebuild the label
					StringBuffer labelBuffer = new StringBuffer();
					for(String s: labelList) {
						labelBuffer.append(s);
					}
					n.setLabel(labelBuffer.toString());
				}
				contourHoleLabelMap.put(holeString, c);
			}
		}
		
		
	}
	
	
	/**
	 * Find the char that is captial version of the given char, or if already
	 * exists, find the next one.
	 */
	public char findNewChar(char c) {
		char ret = 'A';
		if(c>= 'a' && c <= 'z') {
			int diff = (int)'A' - (int)'a';
			int retInt = (int)c+diff;
			ret = (char)retInt;
		}
		
		StringBuffer currentBuff = new StringBuffer();
		if(contourDuplicateLabelMap != null) {
			for(String s : contourDuplicateLabelMap.keySet()) {
				currentBuff.append(s);
				currentBuff.append(contourDuplicateLabelMap.get(s));
			}
		}
		if(contourHoleLabelMap != null) {
			for(String s : contourHoleLabelMap.keySet()) {
				currentBuff.append(s);
				currentBuff.append(contourHoleLabelMap.get(s));
			}
		}

		String current = currentBuff.toString();
		
		while(current.contains(Character.toString(ret))) {
			ret++;
			while(ret >= 'a' && ret <= 'z') {
				ret++;
			}
		}
		
		return ret;
	}
	
	
	
	
	
	/**
	 * Reverts the node labels of the contour label maps to the old labels.
	 */
	public void restoreRenamedContours() {
		
		for(String c : contourDuplicateLabelMap.keySet()) {
			
			String restoreC = contourDuplicateLabelMap.get(c);
			if(restoreC.equals(c)) {
				continue;
			}
			
			for(Node n : getNodes()) {
				String label = n.getLabel();
				if(!label.contains(c)) {
					continue;
				}
				
				ArrayList<String> labelList = AbstractDiagram.findContourList(label);
				labelList.remove(c);
				labelList.add(restoreC);
				Collections.sort(labelList);
				
				// rebuild the label
				StringBuffer labelBuffer = new StringBuffer();
				for(String s: labelList) {
					labelBuffer.append(s);
				}
				n.setLabel(labelBuffer.toString());
			}
		}
		
		for(String c : contourHoleLabelMap.keySet()) {
			
			String outerC = contourHoleLabelMap.get(c);
			if(outerC.equals(c)) {
				continue;
			}
			
			for(Node n : getNodes()) {
				String label = n.getLabel();
				if(!label.contains(c)) {
					continue;
				}
				
				ArrayList<String> labelList = AbstractDiagram.findContourList(label);
				labelList.remove(c);
				labelList.remove(outerC);
				Collections.sort(labelList);
				
				// rebuild the label
				StringBuffer labelBuffer = new StringBuffer();
				for(String s: labelList) {
					labelBuffer.append(s);
				}
				n.setLabel(labelBuffer.toString());
			}
		}
		
		// reset the maps
		contourDuplicateLabelMap = null;
		contourHoleLabelMap = null;
		
	}



	/**
	 * Forms two lists: 
	 * 1. list of edges that are removable, i.e., the removal of an edge 
	 *    in the list does not affect the connectivity of the graph
	 * 2. list of edges that are not removable, i.e., the removal of an 
	 *    edge in the list affects the connectivity of the graph
	 **/
	public void generateConnectivityRemovableUnRemovableEdges(){
		removableEdges = new ArrayList<Edge>();
		unremovableEdges = new ArrayList<Edge>();
		
		for(Edge edgeToRemove : edges){
		 	//System.out.println("remove edge... " + edgeToRemove.toString());
			if(checkConnectivity(edgeToRemove))
				removableEdges.add(edgeToRemove);
			else
				unremovableEdges.add(edgeToRemove);

		}
	/*	System.out.println("removable edges " + removableEdges.size());
		for(Edge e : removableEdges){
			System.out.println(e.toString());
		}
		 System.out.println("unremovable edges");
		for(Edge e1 : unremovableEdges){
			System.out.println(e1.toString());
		} */
	}
	
	/**
	 * A deep copy of the abstract graph, attempting to duplicate nodes and edges
	 **/
	public DualGraph clone() {
			
		DualGraph ret = new DualGraph();
		Graph clonedGraph = super.clone();			
		
		ret.label = clonedGraph.getLabel();
		ret.nodes = clonedGraph.getNodes();
		ret.edges = clonedGraph.getEdges();
		
		return ret;
	}
	
	
	/**
	 * A set of contours is nested if all the contours are entirely contained
	 * in a zone. This returns the first level of nesting, so that to get
	 * repeated nesting, the method needs to be called on the subdiagrams,
	 * after the top node is removed until the result is empty.
	 * A sub diagram is nested if it connects
	 * to only one node in the main diagram, and all node labels in the
	 * subdiagram entirely contain the connecting node label. This method returns
	 * the connecting node as well. The graph label is given the label of the
	 * connecting node.
	 * If the empty zone is present and contains disconnected subdiagrams,
	 * then these subdiagrams are returned.
	 * 
	 * NOTE if we have disconnected subdiagrams of the form a abc, with
	 * no edge between nodes a and abc, then this method will not work. All
	 * subdiagrams must be connected to their containing zone.
	 * 
	 * @param deleteFromOriginal, if set this removes the sub diagram, but not the connecting node.
	 */
	public ArrayList<DualGraph> findNestedSubdiagrams(boolean deleteFromOriginal) {
				
		ArrayList<DualGraph> ret = new ArrayList<DualGraph>();
		
		if(nodes.size() <= 1) {
			return ret;
		}

		// check each subgraph off each edge of each node for a 
		// suitable subdiagram. There maybe more efficient mechansims
		// but this is not too bad
		
		ArrayList<Node> nodesInSubdiagrams = new ArrayList<Node>();
		
		ArrayList<Node> nodes = new ArrayList<Node>(getNodes());
		
		// sort the nodes so that top level nodes are considered first
		ZoneNodeComparator zComp = new ZoneNodeComparator();
		Collections.sort(nodes,zComp);
		
		// test the top level node for disconnected subgraphs
		Node first = nodes.get(0);
		if(first.getLabel().equals("")) {
			ArrayList<DualGraph> disconnectedSubgraphs = new ArrayList<DualGraph>();
			setNodesVisited();
			first.setVisited(true);
			ArrayList<Node> unvisited = unvisitedNodes();
			while(unvisited.size() > 0) {
				// get any unvisitedNode and find a subgraph
				Iterator<Node> nit = unvisited.iterator();
				Node nextNode = nit.next();
		
				ArrayList<Node> subNodes = connectedUnvisitedNodes(nextNode);
				subNodes.add(new Node("0")); // outside node not included in subgraphs
				DualGraph newDG = createNewDualGraphFromNodes(subNodes);
				newDG.setLabel("");
				
				disconnectedSubgraphs.add(newDG);
				
				unvisited = unvisitedNodes();
			}
			
			if(disconnectedSubgraphs.size() >= 2) {
				// only exit at this point if we have multiple disconnected subgraphs
				if(deleteFromOriginal) {
					// top level will always be the only zone
					generateAbstractGraph(new AbstractDiagram("0"));
					directEdges();
					labelEdgesWithContours();
				}
				return disconnectedSubgraphs;
			}
		}
		
		// now search for proper subdiagrams
		
		for(Node n : nodes) {
			
			setNodesVisited();
			setEdgesVisited(); // set here so that a ab ac abc does not return two results for a
			
			// don't test outside node, it contains all other nodes
			if(n.getLabel().equals("")) {
				continue;
			}
			// dont test nodes already in subdiagrams
			if(nodesInSubdiagrams.contains(n)) {
				continue;
			}

			for(Edge e : n.connectingEdges()) {
				if(e.getVisited()) {
					// dont traverse any subdiagrams already visited
					continue;
				}
				DualGraph subdiagram = findSubdiagram(n,e);

				if(subdiagram != null) {
					ret.add(subdiagram);
					
					for(Node subNode : subdiagram.getNodes()) {
						
						String subLabel = subNode.getLabel();
						Node subNodeInThisGraph = firstNodeWithLabel(subLabel);
						nodesInSubdiagrams.add(subNodeInThisGraph);
						if(deleteFromOriginal) {
							if(subNodeInThisGraph != n) { // dont remove the top level node
								removeNode(subNodeInThisGraph);
							}
						}
					}
				}
			}
		}
		
		return ret;
	}

	
	/**
	 * Check to see if a connected subgraph off the startNode
	 * Via the start edge contains only nodes containing the
	 * startNode label.
	 */
	public DualGraph findSubdiagram(Node startNode, Edge startEdge) {
		
		ArrayList<Node> subdiagramNodes = new ArrayList<Node>();
		subdiagramNodes.add(startNode);
		
		startNode.setVisited(true);
		startEdge.setVisited(true);
		
		String startLabel = startNode.getLabel();
		
		ArrayList<Node> queue = new ArrayList<Node>();
		Node firstNode = startEdge.getOppositeEnd(startNode);
		if(firstNode.getVisited()) {
			return null;
		}
		subdiagramNodes.add(firstNode);
		firstNode.setVisited(true);
		queue.add(firstNode);
		while(!queue.isEmpty()) {
			Node n = queue.get(0);
			queue.remove(0);
			if(!DualGraph.findLabelContainment(startLabel,n.getLabel()) && !startLabel.equals(n.getLabel())) {
				// label not contained in node label, so false
				return null;
			}
			// if there are visited connecting nodes not in
			// this subdiagram, it is not a subdiagram
			ArrayList<Node> visitedConnectingNodes = new ArrayList<Node>();
			for(Node connectingNode : n.connectingNodes()) {
				if(connectingNode.getVisited()) {
					visitedConnectingNodes.add(connectingNode);
				}
			}
			visitedConnectingNodes.remove(firstNodeWithLabel("")); // the empty node is always set visited
			ArrayList<Node> shared = nodeListDifference(visitedConnectingNodes,subdiagramNodes);
			if(shared.size() > 0) {
				return null;
			}
			
			ArrayList<Edge> unvisitedEdges = n.unvisitedConnectingEdges();
			for(Edge e : unvisitedEdges) {
				e.setVisited(true);
				Node connectingNode = e.getOppositeEnd(n);
				if(!connectingNode.getVisited()) {
					connectingNode.setVisited(true);
					// get the edges and nodes not yet traversed
					queue.add(connectingNode);
					subdiagramNodes.add(connectingNode);
				}
			}
		}

		DualGraph retDG = createNewDualGraphFromNodes(subdiagramNodes);
		retDG.setLabel(startLabel);
		
		// note could give the node and edge characteristics like type
		// and location here
		
		return retDG;
	}
	

	/** Return the nodes in both lists */
	public static ArrayList<Node> nodeListIntersection(ArrayList<Node> list1, ArrayList<Node> list2) {
		ArrayList<Node> ret = new ArrayList<Node>();
		for(Node n1 : list1) {
			for(Node n2 : list2) {
				if(n1 == n2) {
					ret.add(n1);
				}
			}
		}
		return ret;
	}


	/** Return the nodes in the first list that are not in the second */
	public static ArrayList<Node> nodeListDifference(ArrayList<Node> list1, ArrayList<Node> list2) {
		ArrayList<Node> ret = new ArrayList<Node>(list1);
		for(Node n2 : list2) {
			ret.remove(n2);
		}
		return ret;
	}


	/**
	 * Construct the abstract diagram and dual graph from the node labels
	 * need a completely new diagram and set of nodes and edges
	 */
	protected DualGraph createNewDualGraphFromNodes(ArrayList<Node> nodes) {
		StringBuffer adSB = new StringBuffer("");
		for(Node n : nodes) {
			adSB.append(n.getLabel()+" ");
		}
		AbstractDiagram retAD = new AbstractDiagram(adSB.toString());
		DualGraph retDG = new DualGraph(retAD);
		
		return retDG;
	}

	/**
	 * Deletes edges of the given type
	 */
	public void deleteEdgesOfType(String edgeTypeLabel) {
		ArrayList<Edge> deleteList = new ArrayList<Edge>();
		for(Edge e : getEdges()) {
			if(e.getType().getLabel().equals(edgeTypeLabel)) {
				deleteList.add(e);
			}
		}
		for(Edge e : deleteList) {
			removeEdge(e);
		}

	}
	


	
	/**
	 * This generates the TriangulationEdges NOTE formFaces() must be called
	 * before this is executed.
	 */
/*	public void triangulate() {
		triangulationFaces = new ArrayList<TriangulationFace>();
		
		Face outerFace = getOuterFace();
	
		// generate the triangulation
		ArrayList<Face> faces = getFaces();
		
		for(Face face : faces) {
			if(face == outerFace) {
				//System.out.println("Outer");
				continue;
			}
			triangulateFace(face);
		}
	}
*/	
	
	/**
	 * Takes a face and creates the triangle faces, using any existing
	 * triangulation edges.
	 */
	public void triangulateFace(Face face) {
		ArrayList<Node[]> nodeTripleList = face.generateTrisNodeList();
		for(Node[] nodeTriple : nodeTripleList) {
			Node n0 = nodeTriple[0];
			Node n1 = nodeTriple[1];
			Node n2 = nodeTriple[2];
			
			if(findTriangulationFace(n0,n1,n2) != null) {
				return;
			}
			
			TriangulationEdge te1 = findTriangulationEdge(n0,n1);
			if(te1 == null) {
				Edge e1 = getEdge(n0,n1);
				te1 = new TriangulationEdge(n0,n1,e1,face);
			} else {
				te1.addFace(face);
			}

			TriangulationEdge te2 = findTriangulationEdge(n0,n2);
			if(te2 == null) {
				Edge e2 = getEdge(n0,n2);
				te2 = new TriangulationEdge(n0,n2,e2,face);
			} else {
				te2.addFace(face);
			}

			TriangulationEdge te3 = findTriangulationEdge(n1,n2);
			if(te3 == null) {
				Edge e3 = getEdge(n1,n2);
				te3 = new TriangulationEdge(n1,n2,e3,face);
			} else {
				te3.addFace(face);
			}
			
			addTriangulationFace(face, te1, te2, te3);
		}
	}


	/**
	 * Find a nodes that, when removed, disconnects the graph.
	 * Uses a breadth first search.
	 * @return any articulation node, or null if there is none.
	 */
	public Node findArticulationNode() {
		
		if(getNodes().size() < 3) {
			return null;
		}		
		if(!connected()) {
			return null;
		}		
		for(Node n : getNodes()) {
			setNodesVisited(false);
			n.setVisited(true);
			ArrayList<Node> otherNodes = unvisitedNodes();
			Node startNode = null;
			for(Node tempN : otherNodes) {
				startNode = tempN;
				break;
			}
			ArrayList<Node> queue = new ArrayList<Node>();
			queue.add(startNode);
			startNode.setVisited(true);
			while(queue.size() != 0) {
				Node next = queue.get(0);
				queue.remove(0);
				ArrayList<Node> nextNodes = next.unvisitedConnectingNodes();
				queue.addAll(nextNodes);
				setNodesVisited(nextNodes, true);
			}
			ArrayList<Node> remainingNodes = unvisitedNodes();
			if(remainingNodes.size() > 0) {
				return n;
			}
			
		}
		
		return null;
	}

	
	/**
	 * Find the subgraphs created by removal of a the given node.
	 * If the node passed is not an articulation node, then only one
	 * subgraph is passed. To find disconnected subgraphs without
	 * removing a node, pass this method null.
	 */
	public ArrayList<ArrayList<Node>> findDisconnectedSubGraphs(Node articulationNode) {
		
		ArrayList<ArrayList<Node>> ret = new ArrayList<ArrayList<Node>>();
		
		setNodesVisited(false);
		if(articulationNode != null) {
			articulationNode.setVisited(true);
		}
		ArrayList<Node> remainingNodes = unvisitedNodes();
		while(remainingNodes.size() != 0) {
			ArrayList<Node> queue = new ArrayList<Node>();
			ArrayList<Node> nextSubgraph = new ArrayList<Node>();
			Node startNode = null;
			for(Node tempN : remainingNodes) {
				startNode = tempN;
				break;
			}
			queue.add(startNode);
			nextSubgraph.add(startNode);
			
			startNode.setVisited(true);
			while(queue.size() != 0) {
				Node next = queue.get(0);
				queue.remove(0);
				ArrayList<Node> nextNodes = next.unvisitedConnectingNodes();
				queue.addAll(nextNodes);
				nextSubgraph.addAll(nextNodes);
				setNodesVisited(nextNodes, true);
			}
			ret.add(nextSubgraph);
			remainingNodes = unvisitedNodes();
		}
		
		return ret;
	}
	

	/**
	 * This generates the TriangulationEdges NOTE formFaces() must be called
	 * before this is executed.
	 */
	public void triangulate() {
		triangulationFaces = new ArrayList<TriangulationFace>();
		
		Face outerFace = getOuterFace();
	
		// generate the triangulation
		ArrayList<Face> faces = getFaces();

		for(Face face : faces) {
			if(face == outerFace) {
				continue;
			}
//			triangulateFace(face);
			triangulateSingularlyConnectedFace(face);

		}
	}


	/**
	 * This replaces triangulateFace to fix the problems
	 * with triangulating a graph with an articulation point.
	 * It also allows the triangulation of faces that contains
	 * a face inside itself.
	 */
	public void triangulateSingularlyConnectedFace(Face oldFace) {
		HashMap<Node,Node> oldToNewNodeMap = new HashMap<Node,Node>();
		HashMap<Node,Node> newToOldNodeMap = new HashMap<Node,Node>(); 
		DualGraph newGraph = new DualGraph(); // duplicate the nodes
		for(Node oldN : oldFace.getNodeList()) {
			Node newN = new Node(oldN.getLabel());
			newGraph.addNode(newN);
			newN.setCentre(oldN.getCentre());
			oldToNewNodeMap.put(oldN,newN);
			newToOldNodeMap.put(newN,oldN);
		}
		
		for(FaceEdge fe : oldFace.getFaceEdgeList()) { // add in the edges from the original graph
			Node newN1 = oldToNewNodeMap.get(fe.getFrom());
			Node newN2 = oldToNewNodeMap.get(fe.getTo());
			if(newN1 !=null && newN2!=null 
					&& !newN1.connectingNodes().contains(newN2)) {
				Edge e = new Edge(newN1,newN2);
				newGraph.addEdge(e);
			}
		}
		
		Node articulationNode = newGraph.findArticulationNode();
		if(articulationNode == null) {
			// no need to muck about if there is no problem with the face
			triangulateFace(oldFace);
			return;
		}
		
		while(articulationNode != null) {
			ArrayList<ArrayList<Node>> nodeLists = newGraph.findDisconnectedSubGraphs(articulationNode);
			ArrayList<Node> firstList = nodeLists.get(0);
			nodeLists.remove(0);
			ArrayList<Node> remainingList = new ArrayList<Node>();
			for(ArrayList<Node> nl : nodeLists) {
				remainingList.addAll(nl);
			}
			
			Node firstNode = firstList.get(0);
			Node nearestNode = ConcreteDiagram.findNearestNodeWithoutCrossing(newGraph,firstNode.getCentre(),remainingList);
			
			Edge e = new Edge(firstNode,nearestNode);
			e.setType(ConcreteDiagram.outerEdgeType);
			newGraph.addEdge(e);
			
			articulationNode = newGraph.findArticulationNode();
		}
		
		newGraph.formFaces();
		//get a triangulation for the outer faces
		Face cloneOuterFace = newGraph.getOuterFace();
		for(Face newFace : newGraph.getFaces()) {
			if(newFace == cloneOuterFace) {
				// dont want the outside face triangulated
				continue;
			}
			// this test is required because of possible loops in the inner face
			boolean insideFace = false;
			for(Edge e : newFace.findEdgeList()) {
				if(e.getType() == ConcreteDiagram.outerEdgeType) {
					insideFace = true;
					break;
				}
			}
			if(!insideFace) {
				continue;
			}
			newGraph.triangulateFace(newFace);	
		}

		
//DualGraphWindow dw = new DualGraphWindow(newGraph);
		
		
		// convert the triangulation back to the original graph
		for(TriangulationFace cloneTF : newGraph.getTriangulationFaces()) {
			
			TriangulationEdge cloneTE1 = cloneTF.getTE1();
			TriangulationEdge cloneTE2 = cloneTF.getTE2();
			TriangulationEdge cloneTE3 = cloneTF.getTE3();

			Node from1 = firstNodeAtPoint(cloneTE1.getFrom().getCentre());
			Node to1 = firstNodeAtPoint(cloneTE1.getTo().getCentre());
			Edge e1 = getEdge(from1,to1);
			TriangulationEdge te1 = findTriangulationEdge(from1,to1);
			if(te1 == null) {
				te1 = new TriangulationEdge(from1,to1,e1,oldFace);
			} else {
				te1.addFace(oldFace);
			}
			
			Node from2 = firstNodeAtPoint(cloneTE2.getFrom().getCentre());
			Node to2 = firstNodeAtPoint(cloneTE2.getTo().getCentre());
			Edge e2 = getEdge(from2,to2);
			TriangulationEdge te2 = findTriangulationEdge(from2,to2);
			if(te2 == null) {
				te2 = new TriangulationEdge(from2,to2,e2,oldFace);
			} else {
				te2.addFace(oldFace);
			}

			Node from3 = firstNodeAtPoint(cloneTE3.getFrom().getCentre());
			Node to3 = firstNodeAtPoint(cloneTE3.getTo().getCentre());
			Edge e3 = getEdge(from3,to3);
			TriangulationEdge te3 = findTriangulationEdge(from3,to3);
			if(te3 == null) {
				te3 = new TriangulationEdge(from3,to3,e3,oldFace);
			} else {
				te3.addFace(oldFace);
			}
			
			addTriangulationFace(oldFace,te1,te2,te3);
			
		}


	}



	
	
	/**
	 * Returns a triangulation face with the nodes as corners, or null
	 * if there is no such face
	 */
	public TriangulationFace findTriangulationFace(Node n1,Node n2,Node n3) {
		
		for(TriangulationFace tf : triangulationFaces) {
			if(tf.getNode1() != n1 && tf.getNode2() != n1 && tf.getNode3() != n1) {
				continue;
			}
			if(tf.getNode1() != n2 && tf.getNode2() != n2 && tf.getNode3() != n2) {
				continue;
			}
			if(tf.getNode1() != n3 && tf.getNode2() != n3 && tf.getNode3() != n3) {
				continue;
			}
			return tf;
		}
		
		return null;
	}


	/**
	 * Returns a triangulation face with the nodes as corners, or null
	 * if there is no such face
	 */
	public TriangulationFace firstTriangulationFaceWithNodeLabels(String l1,String l2,String l3) {
		
		for(TriangulationFace tf : triangulationFaces) {
			if(!tf.getNode1().getLabel().equals(l1) && !tf.getNode2().getLabel().equals(l1) && !tf.getNode3().getLabel().equals(l1)) {
				continue;
			}
			if(!tf.getNode1().getLabel().equals(l2) && !tf.getNode2().getLabel().equals(l2) && !tf.getNode3().getLabel().equals(l2)) {
				continue;
			}
			if(!tf.getNode1().getLabel().equals(l3) && !tf.getNode2().getLabel().equals(l3) && !tf.getNode3().getLabel().equals(l3)) {
				continue;
			}
			return tf;
		}
		
		return null;
	}
	
	
	public void setTriangulationEdgesVisited(boolean b) {
		for(TriangulationEdge te : findTriangulationEdges()) {
			te.setVisited(b);
		}
	}
	



	
	/**
	 * Searches through the triangulation faces to see if any
	 * have a triangulation edge with the same end points.
	 * Returns null if there is no such edge.
	 */
	public TriangulationEdge findTriangulationEdge(Node n1, Node n2) {
		for(TriangulationFace tf : getTriangulationFaces()) {
			TriangulationEdge te;
			te = tf.getTE1();
			if(te.getFrom() == n1 && te.getTo() == n2) {return te;}
			if(te.getTo() == n1 && te.getFrom() == n2) {return te;}
			
			te = tf.getTE2();
			if(te.getFrom() == n1 && te.getTo() == n2) {return te;}
			if(te.getTo() == n1 && te.getFrom() == n2) {return te;}
			
			te = tf.getTE3();
			if(te.getFrom() == n1 && te.getTo() == n2) {return te;}
			if(te.getTo() == n1 && te.getFrom() == n2) {return te;}
		}
		return null;
	}
	

	/**
	 * Finds the first TriangulationEdge in the graph with the given label.
	 * @return null if there is no such TriangulationEdge.
	 */
	public TriangulationEdge firstTriangulationEdgeWithContour(String contour) {

		for(TriangulationEdge te : findTriangulationEdges()) {
			if(te.contourLinksWithContour(contour).size() != 0) {
				return te;
			}
		}

		return null;
	}
	
	
	/**
	 * Removes the nodes and edges and triangulation information from the graph,
	 * leaving an empty graph. This is a destructive clear as nodes are removed from the graph, so
	 * loosing their edge connections.
	 */
	public void clear() {
		Iterator<Node> ni = nodes.iterator();
		while(ni.hasNext()) {
			Node n = ni.next();
			removeNode(n);
			ni = nodes.iterator();
		}
		
		Iterator<TriangulationFace> tfi = triangulationFaces.iterator();
		while(tfi.hasNext()) {
			TriangulationFace tf = tfi.next();
			removeTriangulationFace(tf);
			tfi = triangulationFaces.iterator();
		}
	}
	
	/**
	 * Print out the edges and nodes of the graph
	 */
		public void printAll(){			
		System.out.println("abstract graph : ");
		System.out.println("nodes;");
		for(Node n : nodes){
			System.out.println(n.toString());
		//	System.out.println(n.getCentre().toString());
		}
		System.out.println("edges:");
		for(Edge e: edges){	
			System.out.println("edge " + e.getFrom().getLabel()  +"  " +e.getTo().getLabel());
			System.out.println(e.getFrom().getCentre().toString() + " " + e.getTo().getCentre().toString());
		/*	if(e.getBends().size()!=0){
				for(Point p :e.getBends()){
					System.out.println(p.toString());
				}
			}*/
		}
	
	}

	/**
	 * Attempt to turn this graph into a well formed planar one, if successful
	 * it returns a new graph with the edges removed, otherwise it returns null.
	 */
	public DualGraph findWellformedPlanarGraph() {	
			
			generateConnectivityRemovableUnRemovableEdges();
			// System.out.println("start to search for wellformed planar dual");
			long startTime = System.currentTimeMillis();
			if(removableEdges.size()!=0){				
				ArrayList<ArrayList<Edge>> savedList = new ArrayList<ArrayList<Edge>>();
				int count = 0;
				boolean stop = false;
				
				int emptyNodeIndex = 0;		
				
			
				
				while(!stop){
				    int j =1;
					for( j = 1; j < 3; j++){						
						count++;
						for(int l = 0 ; l < nodes.size(); l++){
							if(nodes.get(l).getLabel().compareTo("")==0
									||nodes.get(l).getLabel().compareTo("0")==0)
							emptyNodeIndex = l;
							//System.out.println("empty node index " + emptyNodeIndex);	
							
						}
					
						//System.out.println(j);
					 	ArrayList<ArrayList<Edge>> elist = possibleCombinations(j, removableEdges);
					 	int numberOfSkip = 0;
					 	for(int  k = 0 ; k < elist.size(); k++){
							ArrayList<Edge> edgesToRemove = elist.get(k);

							if(!inList(savedList, edgesToRemove) ){

								DualGraph temp = cloneGraphWithRemovedEdges(this, edgesToRemove);							
								double [] coor = temp.getOGDFNodesCoor();							
								int edgesIndex[] = temp.getOGDFEdgesIndex();
								double [] newCoor = euler.OGDFPlanar.planarEmbedding(coor, edgesIndex, temp.getNodes().size(), temp.getEdges().size(),emptyNodeIndex);		
								
								boolean connected = temp.checkConnectivity();
								if(!connected){
									savedList.add(edgesToRemove);
								//	System.out.println("disconnected, save to list");
								}
								if(connected && newCoor!=null ){	
									System.out.println("planarity gained after removing edge (s)");
									for(Edge e: edgesToRemove){
										System.out.println(e.toString());
									}
									return temp;
								}								
							}						
							
							else{
								numberOfSkip ++;
							}
							if( numberOfSkip == elist.size()){
								System.out.println("stop searching for new wellformed planar dual due to no graph is connected after + " +  j + "edge removal");
								stop = true;
							}
					 	}
					 	 if((System.currentTimeMillis() - startTime) > timeLimit) {
						 		System.out.println("stop searching due to time expiry after "+timeLimit+" milliseconds");
						 		stop = true;
					 	 }
					
					} 

					 if((System.currentTimeMillis() - startTime) > timeLimit) {
						 		System.out.println("stop searching due to time expiry after "+timeLimit+" milliseconds");
						 		stop = true;
					}
				}

			}
			// System.out.println("no wellformed planar dual can be found after edge removing...");
			return null;	
	}
	
	
	public boolean inList(ArrayList<ArrayList<Edge>> disConnectedList, ArrayList<Edge> currentList){
		
		boolean found  = false;
		
		for(int i = 0 ; i < disConnectedList.size(); i++){
			ArrayList<Edge> temp = disConnectedList.get(i);
			if(currentList.containsAll(temp))
				found = true;
		}
		
		return found;
	}

	/*
	 * given a edge list, generate possible combinations
	 * */
	private static ArrayList<ArrayList<Edge>> possibleCombinations( int noOfSet, ArrayList<Edge> edgeList){
		
		// System.out.println("no of set " + noOfSet);
		 ArrayList<ArrayList<Edge>> ret = new ArrayList<ArrayList<Edge>>();
		 Combination com = new Combination(noOfSet,edgeList.size());
		 int[] next = com.next();
		  while(next!=null){
			  ArrayList<Edge> eList = new ArrayList<Edge>();
			  for(int i = 0 ; i < next.length; i++){
				  eList.add(edgeList.get(next[i]));
			  }
			  next = com.next();
			  ret.add(eList);
		  }

		  
		return ret;
	}

		
	public static DualGraph findNonWellformedPlanarGraph(DualGraph dualGraph) {	
		
		long startTime = System.currentTimeMillis();
		boolean stop = false;
		// System.out.println("start searching for non wellformed planar dual...");
		boolean planar = false;
		DualGraph dg = dualGraph.clone();	
		ArrayList<Edge> removedEdges = new ArrayList<Edge>();		
		
		int emptyNodeIndex = 0;			
		for(int i = 0 ; i <dg. nodes.size(); i++){
			if(dg.nodes.get(i).getLabel().compareTo("")==0){
				emptyNodeIndex = i;				
			}
		}		
		while(!planar && dg.getEdges().size()!=0  && !stop){			
			int noOfEdgeCrossing[] = new int[dg.getEdges().size()];
				
			for(int i = 0 ; i < dg.getEdges().size(); i++){
				int noOfCrossing = 0;
				Edge e1 = dg.getEdges().get(i);
				Point p1 = e1.getFrom().getCentre();
				Point p2 = e1.getTo().getCentre();
				for(int j = 0 ; j < dg.getEdges().size(); j++){
					 Edge e2 = dg.getEdges().get(j);
					 Point p3 = e2.getFrom().getCentre();
					 Point p4 = e2.getTo().getCentre();
					 if(pjr.graph.Util.linesCross(p1, p2, p3, p4))
						noOfCrossing++;
				}
				noOfEdgeCrossing[i] = noOfCrossing;
			}
			int maxNoCrossing = 0;
			int maxIndex = 0;
			for(int k = 0 ; k < noOfEdgeCrossing.length; k++){
				if(noOfEdgeCrossing[k] > maxNoCrossing){
					maxNoCrossing = noOfEdgeCrossing[k];
						maxIndex = k;
				}
			}

			Edge removedEdge = dg.getEdges().get(maxIndex);
			// System.out.println("remove edge " + removedEdge.toString());
			Edge newEdge = new Edge(removedEdge.getFrom(),removedEdge.getTo());
			removedEdges.add(newEdge);
			if(	!dg.removeEdge(removedEdge)){System.out.println("failed to remove edge");}
			double [] coor = dg.getOGDFNodesCoor();							
			int edgesIndex[] = dg.getOGDFEdgesIndex();
			for(int j = 0 ; j < dg.getNodes().size(); j++){
				if(dg.getNodes().get(j).getLabel().compareTo("")==0
						||dg.getNodes().get(j).getLabel().compareTo("0")==0)					
				emptyNodeIndex = j;
				//System.out.println("empty node index " + emptyNodeIndex);	
			}
			double [] newCoor = euler.OGDFPlanar.planarEmbedding(coor, edgesIndex, dg.getNodes().size(), dg.getEdges().size(),emptyNodeIndex);		
			if(newCoor!=null){
				planar = true;
				//System.out.println("found a non wellformed planar dual...");
				dg = optimiseNonWellformedGraph(dg,removedEdges);
				return dg;
			}
			if((System.currentTimeMillis() - startTime) > NONWELLFORMED_TIME_LIMIT) {
				//System.out.println("stop searching for non wellformed planar dual due to time expiry after "+NONWELLFORMED_TIME_LIMIT+" milliseconds");				
				stop = true;
			}
 		}	
			
			
			return null;

		
	}
	public static DualGraph optimiseNonWellformedGraph(DualGraph dg, ArrayList<Edge> removedEdges){
		
		long startTime = System.currentTimeMillis();
		// System.out.println("removed edges size " + removedEdges.size());
		DualGraph betterGraph = dg.clone();

		
		boolean stop = false;
		while(!stop){
			for(int i = 1; i < removedEdges.size()+1; i++){
				//System.out.println("dg edge number" + dg.getEdges().size());
			//	System.out.println("start to add " + i + "");
				ArrayList<ArrayList<Edge>> elist = possibleCombinations(i, removedEdges);
			
				for(int j = 0 ; j < elist.size(); j++){
					DualGraph dg1 = dg.clone();
					ArrayList<Edge> addBack = elist.get(j);
					//System.out.println("add back edges" + addBack.size());
					for(Edge e: addBack){
					//System.out.println(e.toString());
						Node start = null;
						Node end = null;
						for(Node n: dg1.getNodes()){
						if(n.getLabel().compareTo(e.getFrom().getLabel()) == 0)
							start = n;
						if(n.getLabel().compareTo(e.getTo().getLabel()) == 0)
							end = n;
						}
						dg1.addEdge(new Edge(start,end));											
					}
					int emptyNodeIndex = 0;			
					for(int k = 0 ; k <dg1. nodes.size(); k++){
						if(dg1.nodes.get(i).getLabel().compareTo("")==0
								||dg1.getNodes().get(j).getLabel().compareTo("0")==0){
							emptyNodeIndex = k;
							//System.out.println("empty node index " + k);
						}
					}
					
					double [] coor1 = dg1.getOGDFNodesCoor();							
					int edgesIndex1[] = dg1.getOGDFEdgesIndex();
					double [] newCoor1 = euler.OGDFPlanar.planarEmbedding(coor1, edgesIndex1, dg1.getNodes().size(), dg1.getEdges().size(),emptyNodeIndex);		
					if(newCoor1 != null && dg1.checkConnectivity()){					
						// System.out.println("After add back edges, found a wellformed planar dual...");
						dg1.printAll();
						stop = true; 
						return dg1;
					}	
				/*	if(newCoor1 != null && dg1.getEdges().size()> betterGraph.getEdges().size()){
						betterGraph = dg1;
						System.out.println("better connected graph edge number " + betterGraph.getEdges().size() );
					}*/
				}
				if((System.currentTimeMillis() - startTime) > NONWELLFORMED_TIME_LIMIT) {
					// System.out.println("stop optimise for non wellformed planar dual due to time expiry after "+NONWELLFORMED_TIME_LIMIT+" milliseconds");				
					stop = true;
				}
			}
		}
		return betterGraph;
	}
	
	public DualGraph cloneGraphWithRemovedEdge(DualGraph dg, String start, String end){
		
		DualGraph ret = dg.clone();
		//System.out.println("graph with removed edge " + start + " " + end);
		for(int i = 0 ; i < dg.getEdges().size(); i++){
			Edge e = dg.getEdges().get(i);
			if((e.getFrom().getLabel().compareTo(start)==0 
					&& e.getTo().getLabel().compareTo(end) ==0)
					||e.getTo().getLabel().compareTo(start)==0 
					&& e.getFrom().getLabel().compareTo(end) ==0){
					Edge deleteEdge = ret.getEdges().get(i);
					ret.removeEdge(deleteEdge);
					break;
			}
			else{
			//	System.out.println(e.toString());
			}
		}

		return ret;
	}
	
	
	public DualGraph cloneGraphWithRemovedEdges(DualGraph dg, ArrayList<Edge> edgeList){
	
		DualGraph ret = dg.clone();
		for(Edge e : edgeList){
			DualGraph temp = ret.clone();
			ret = cloneGraphWithRemovedEdge(temp,e.getFrom().getLabel(), e.getTo().getLabel());			
		}
		return ret;
	}
	

	/**
	 * Finds the first node in the graph containing the argument
	 * as a substring.
	 * @return null if there is no such node.
	 */
	public Node firstNodeContainingLabel(String subLabel) {

		Iterator<Node> ni = getNodes().iterator();
		while(ni.hasNext()) {
			Node n = ni.next();
			if(n.getLabel().contains(subLabel)) {
				return n;
			}
		}
		return null;
	}	
	/**
	 * Returns the triangulation edge crossings in the graph.
	 * It gives a list of 2 element arrays, each
	 * element in the list is a pair of crossing TEs.
	 */
	public ArrayList<TriangulationEdge[]> findTriangulationEdgeCrossings() {

		ArrayList<TriangulationEdge[]> ret = new ArrayList<TriangulationEdge[]>();
		
		ArrayList<TriangulationEdge> TEs = new ArrayList<TriangulationEdge>(findTriangulationEdges());
		
		for(int i1 = 0; i1< TEs.size(); i1++) {
			for(int i2 = i1+1; i2< TEs.size(); i2++) {
				TriangulationEdge te1 = TEs.get(i1);
				TriangulationEdge te2 = TEs.get(i2);
				
				// edges sharing a node can't cross
				if(te1.getFrom() == te2.getFrom() || te1.getFrom() == te2.getTo()) {
					continue;
				}
				if(te1.getTo() == te2.getFrom() || te1.getTo() == te2.getTo()) {
					continue;
				}
				
				if(pjr.graph.Util.linesCross(te1.getFrom().getCentre(),te1.getTo().getCentre(),te2.getFrom().getCentre(),te2.getTo().getCentre())) {
					TriangulationEdge[] pair = {te1,te2};
					ret.add(pair);
				}
			}
		}
		return ret;
	}


	/**
	 * Add edge between nodes if there is not already one present.
	 * @return the edge, or null if no edge was created.
	 */
	public Edge addUniqueEdge(Node from, Node to) {

		ArrayList<Node> nodes = getNodes();
		if(!nodes.contains(from)) {
			return null;
		}
		if(!nodes.contains(to)) {
			return null;
		}
		for(Edge e : from.getEdgesFrom()) {
			if(e.getTo() == to) {
				return null;
			}
		}
		Edge newEdge = new Edge(from,to);
		addEdge(newEdge);
		return newEdge;
	}

	/*
	 * generate OGDF formate nodes
	 * */
	
	public double[] getOGDFNodesCoor(){
		
		double coor[] = new double[nodes.size()*2];
		int idx = 0;
		for(int i = 0 ; i < nodes.size(); i++){
			Node n = nodes.get(i);
			n.setIndex(i);
			double x = n.getX();
			double y = n.getY();
			coor[idx] = x;
			idx++;
			coor[idx]= y;
			idx++;			
		}
		return coor;
	}
	
	/*
	 * generate edge list (by pairwise index of nodes)for OGDF library
	 * */
	public int[]getOGDFEdgesIndex(){
		int idx = 0;
		int edgesIndex[] = new int[edges.size()*2];
		for(int j = 0 ; j < edges.size(); j++){
			Edge e = edges.get(j);
			int idx1 = e.getFrom().getIndex();
			int idx2 = e.getTo().getIndex();
			edgesIndex[idx] = idx1;
			idx++;
			edgesIndex[idx] = idx2;
			idx++;
		}
		return edgesIndex;
	}


	public void addAllFaceSplits() {
		
		boolean foundSplit = true;
		
		while(foundSplit) {
			foundSplit = findFaceSplit();
		}
		
		
		
	}

	
	/**
	 * Find a face that can be split, and split it by adding an edge.
	 * @return true if the face was split, false otherwise.
	 */
	public boolean findFaceSplit() {

		formFaces();
		
		for(Face f : getFaces()) {
//			DualGraph crossingGraph = generateCrossingGraph(dualGraph,f);
			
			ArrayList<String> addEdgeLabelList = new ArrayList<String>();
			for(FaceEdge fe : f.getFaceEdgeList()) {
				String label = fe.getEdge().getLabel();
				addEdgeLabelList.add(label);
			}
			
			if(addEdgeLabelList.size() == 0) {
				continue;
			}
			
			ArrayList<Node> possibleSplitsi = new ArrayList<Node>();
			ArrayList<Node> possibleSplitsj = new ArrayList<Node>();
			
			// filter out any node thats part of a poly edge
			ArrayList<Node> nodeList = new ArrayList<Node>();
			for(Node n : f.getNodeList()) {
				if(n.getType() != POLY_NODE_TYPE) {
					nodeList.add(n);
				}
			}
			
			for(String addEdgeLabel : addEdgeLabelList) {
				// find all the ways in which an edge labelled with the addEdgeLabel can be created
				for(int i = 0; i < nodeList.size(); i++) {
					Node nodei = nodeList.get(i);
					for(int j = i+1; j < nodeList.size(); j++) {
						Node nodej = nodeList.get(j);
						String diff = DualGraph.findLabelDifferences(nodei.getLabel(), nodej.getLabel());
						if(addEdgeLabel.equals(diff)) {
							possibleSplitsi.add(nodei);
							possibleSplitsj.add(nodej);
						}
					}
				}
			}
			
			// find a split that has all contours which are going to be slid along
			// on both side of the split
			Node splitNodei = null;
			Node splitNodej = null;
			for(int k = 0; k < possibleSplitsi.size(); k++) {
				Node nodei = possibleSplitsi.get(k);
				Node nodej = possibleSplitsj.get(k);
				if(polylineAdjacencyTestInFace(f,nodei,nodej)) {
					// dont add an edge where the nodes are already adjacent.
					continue;
				}
				
				String partialWord1 = f.findPartialWord(nodei,nodej);
				String partialWord2 = f.findPartialWord(nodej,nodei);
				String diff = DualGraph.findLabelDifferences(nodei.getLabel(), nodej.getLabel());
				
				boolean foundGoodSplit = true;
				for(String c : AbstractDiagram.findContourList(diff)) {
					if(!partialWord1.contains(c)) {
						foundGoodSplit = false;
						break;
					}
					if(!partialWord2.contains(c)) {
						foundGoodSplit = false;
						break;
					}
				}
				if(foundGoodSplit) {
					splitNodei = nodei;
					splitNodej = nodej;
					break;
				}
			}
			
			if(splitNodei != null) {
				addEdgeInFace(f,splitNodei,splitNodej);
				return true;
			}
		}
		
		return false;
	}
	
	
	/**
	 * Test to see if two nodes are adjacent, or connected by
	 * poly line made up of poly nodes
	 */
	public boolean polylineAdjacencyTestInFace(Face f, Node nodei, Node nodej) {
		
		ArrayList<Edge> edgesInFace = f.findEdgeList();

		// first test for non polyline adjacency
		for(Edge e : nodei.connectingEdges()) {
			if(edgesInFace.contains(e)) {
				if(e.getOppositeEnd(nodei) == nodej) {
					return true;
				}
			}
		}

		// test for polyline adjacency
		setEdgesVisited(false);

		ArrayList<Edge> queue = null;
		Node currentNode = null;
		while(queue == null || queue.size() != 0) {
			if(queue == null) { // first iteration
				queue = new ArrayList<Edge>();
				currentNode = nodei;
			} else {
				Edge e = queue.get(0);
				currentNode = e.getOppositeEnd(currentNode);
				queue.remove(0);
			}
			if(currentNode == nodej) {
				return true;
			}
			for(Edge e : currentNode.unvisitedConnectingEdges()) {
				e.setVisited(true);
				if(e.getType() == POLY_EDGE_TYPE && edgesInFace.contains(e)) {
					queue.add(e);
				}
			}
		}
		
		
		return false;
	}

	/**
	 * Put an edge (or chain of edges) in the face between the
	 * two nodes.
	 */
	public void addEdgeInFace(Face f, Node node1, Node node2) {
System.out.println("attempting to add edge between "+node1+" "+node2);
		
		if(f != getOuterFace()) { // definitely need a polyline for the outer face
			// route edges in concave faces by a straight line
			// NOTE superseeded by below more general code
/*			if(!pjr.graph.Util.isConcave(f.getPolygon())) {
				String diff = DualGraph.findLabelDifferences(node1.getLabel(), node2.getLabel());
				Edge e = new Edge(node1,node2,diff);
				dualGraph.addEdge(e);
				return;
			}
*/		
			
			Polygon p = f.getPolygon();

			if(euler.Util.lineInPolygon(p, node1.getCentre(), node2.getCentre())) {
				String diff = DualGraph.findLabelDifferences(node1.getLabel(), node2.getLabel());
				Edge e = new Edge(node1,node2,diff);
				addEdge(e);
				return;
			}
		}
			

System.out.println("adding poly edge between '"+node1+"' and '"+node2+"'");

		// extra nodes get the shortest label
		String addLabel = node1.getLabel();
		if(node2.getLabel().length() < node1.getLabel().length()) {
			addLabel = node2.getLabel();
		}
		
		ArrayList<Point> path = findPathThroughFace(f,node1,node2);

		Node currentNode = new Node(addLabel,POLY_NODE_TYPE,path.get(0));
		addNode(currentNode);
		addEdge(new Edge(node1,currentNode,POLY_EDGE_TYPE));
		for(int i = 1; i < path.size(); i++) {
			Node nextNode = new Node(addLabel,POLY_NODE_TYPE,path.get(i));
			addNode(nextNode);
			addEdge(new Edge(currentNode,nextNode,POLY_EDGE_TYPE));
			
			currentNode = nextNode;
		}
		addEdge(new Edge(currentNode,node2,POLY_EDGE_TYPE));
	}
	
	/**
	 * Create a triangulation and find a path between the two nodes
	 * using TEs.
	 */
	public ArrayList<Point> findPathThroughFace(Face f, Node node1, Node node2) {
		
		boolean isOuterFace = false;
		if(getOuterFace() == f) {
			isOuterFace = true;
		}

		DualGraph searchGraph = generateTriangulatedClone();


		
		Node sourceNode = searchGraph.firstNodeAtPoint(node1.getCentre());
		Node targetNode = searchGraph.firstNodeAtPoint(node2.getCentre());
		
		// only want to search through the inner edges
		for(TriangulationEdge te : searchGraph.findTriangulationEdges()) {
			if(te.getEdge() == null) {
				te.setVisited(false);
			} else {
				te.setVisited(true);
			}
		}
		
		// find faces containing the source and target TFs
		ArrayList<TriangulationFace> sourceTFs = new ArrayList<TriangulationFace>();
		ArrayList<TriangulationFace> targetTFs = new ArrayList<TriangulationFace>();
		for(TriangulationFace tf : searchGraph.getTriangulationFaces()) {

			
			// check if the TF is inside the required face
			Point tfCentroid = tf.centroid();
			if(isOuterFace) {
				if(f.getPolygon().contains(tfCentroid)) {
					continue;
				}
			} else {
				if(!f.getPolygon().contains(tfCentroid)) {
					continue;
				}
			}

			
			if(tf.getNode1() == sourceNode) {sourceTFs.add(tf);}
			else if(tf.getNode2() == sourceNode) {sourceTFs.add(tf);}
			else if(tf.getNode3() == sourceNode) {sourceTFs.add(tf);}
			
			if(tf.getNode1() == targetNode) {targetTFs.add(tf);}
			else if(tf.getNode2() == targetNode) {targetTFs.add(tf);}
			else if(tf.getNode3() == targetNode) {targetTFs.add(tf);}
		}
		
		Stack<TriangulationFace> stack = new Stack<TriangulationFace>();

		boolean routeFound = false;		
		while(!routeFound) {
			if(stack.size() == 0) {
				if(sourceTFs.size() == 0) {
					System.out.println("run out of sourceTFs in findPathThroughFace between node1 "+node1+" and node2 "+node2);
					return null;
				}
				stack.push(sourceTFs.get(0));
				sourceTFs.remove(0);
			}

			
			TriangulationFace currentTF = stack.peek();

			if(isOuterFace && !node1.getLabel().equals("") && !node2.getLabel().equals("")) {
				// check to see if the route encloses the empty zone
				// this only happens if it is the outer face and one of the
				// nodes is not the empty node
				
				// now, if the TE includes the empty node then the route
				// will enclose the empty node
//				ArrayList<TriangulationEdge> removeTEs = new ArrayList<TriangulationEdge>();
				for(TriangulationEdge te : currentTF.getUnvisitedTEs()) {
					Node n = te.getFrom();
					if(n.getType() != ConcreteDiagram.outerNodeType && n.getLabel().equals("")) {
						te.setVisited(true);
					}
					n = te.getTo();
					if(n.getType() != ConcreteDiagram.outerNodeType && n.getLabel().equals("")) {
						te.setVisited(true);
					}
				}
			}
			
			ArrayList<TriangulationEdge> unvisitedEdges = currentTF.getUnvisitedTEs();

			if(unvisitedEdges.size() == 0) {
				stack.pop();
			} else {
				TriangulationEdge nextTE = unvisitedEdges.get(0);
				nextTE.setVisited(true);
				TriangulationFace nextTF = nextTE.getTriangulationFaceList().get(0);
				if(nextTF == currentTF) {
					nextTF = nextTE.getTriangulationFaceList().get(1);
				}
				stack.push(nextTF);



			}


			if(targetTFs.contains(stack.peek())) {
				routeFound = true;
			}
		}

//System.out.println(stack);
		
		ArrayList<Point> ret = new ArrayList<Point>();

// This does not work, needs routing by TEs, not TF centres
//		for(TriangulationFace tf : stack) {
//			ret.add(tf.centroid());
//		}

		// route the points through the TEs
		TriangulationFace lastTF = null;
		for(TriangulationFace currentTF : stack) {
			if(lastTF != null) {
				TriangulationEdge te = currentTF.findJoiningTE(lastTF);
				Point middleOfTE = pjr.graph.Util.midPoint(te.getFrom().getCentre(), te.getTo().getCentre());
				ret.add(middleOfTE);
			}
			lastTF = currentTF;
			
		}

//DualGraphWindow dgw = new DualGraphWindow(searchGraph);
//dgw.getDiagramPanel().setShowTriangulation(true);
		
		return ret;
	}
	
	

	/**
	 * Check if removal of nodes labelled with the contours in the string disconnect
	 * the graph.
	 */
	public boolean disconnectsGraph(DualGraph dg, String s) {
		
		DualGraph cloneGraph = dg.clone();
		ArrayList<String> nodeLabels = AbstractDiagram.findContourList(s);
		
		for(String nodeLabel : nodeLabels) {
			Node n = cloneGraph.firstNodeWithLabel(nodeLabel);
			cloneGraph.removeNode(n);
		}
		
		boolean ret = !cloneGraph.connected();
		
//if(ret && s.equals("a")) {
//DualGraphWindow dw = new DualGraphWindow(cloneGraph);
//}
		
		return ret;
	}
	
	
	/**
	 * Generate the crossing graph. Each contour in the face
	 * is a node, and there is an edge between nodes if the contours
	 * cross in the face.
	 */
	public DualGraph generateCrossingGraph(DualGraph dg, Face f) {
		
		DualGraph ret = new DualGraph();
		
		for(String c : f.findContours()) {
			ret.addNode(new Node(c));
		}
		
		ArrayList<String> crossingContours = f.getCrossingContours();
		
		for(String cross : crossingContours) {
			String c1 = cross.substring(0,1);
			String c2 = cross.substring(1,2);
			ret.addAdjacencyEdge(c1, c2);
		}
		
		return ret;
	}

	
	
	public DualGraph generateTriangulatedClone() {
		
		labelEdgesWithContours();
		
		formFaces();

		DualGraph cloneGraph = clone();
		cloneGraph.formFaces();
		Face outerFace = cloneGraph.getOuterFace();
		ArrayList<Node> outerNodes;
		if(outerFace == null) {
			// assume that there is no outer face because the dual forms a straight
			// line or is empty
			outerNodes = cloneGraph.getNodes();
		} else {
			outerNodes = outerFace.getNodeList();
		}
		ConcreteDiagram.addBoundingNodes(cloneGraph,ConcreteDiagram.OUTER_FACE_TRIANGULATION_BOUNDARY,outerNodes);

		// take out the bounding nodes and edges to allow triangulation
		ArrayList<Node> removedNodes = GeneralConcreteDiagram.getBoundingNodes(cloneGraph);
		ArrayList<Edge> removedEdges = GeneralConcreteDiagram.getBoundingEdges(cloneGraph);
		ConcreteDiagram.removeBoundingNodes(cloneGraph);
		
		cloneGraph.formFaces();
		Face cloneOuterFace = cloneGraph.getOuterFace();
		cloneGraph.triangulate();
		
		// add the bounding nodes and edges back in
		for(Node n : removedNodes) {
			cloneGraph.addNode(n);
		}
		for(Edge e : removedEdges) {
			cloneGraph.addEdge(e);
		}

		ConcreteDiagram.triangulateBoundingFace(cloneGraph,cloneOuterFace);		
		return cloneGraph;
	}

	/**
	 * Removes all the poly edges and nodes.
	 */
	public void removeAllPolyEdges() {
		ArrayList<Edge> removeEdges = new ArrayList<Edge>();
		for(Edge e : getEdges()) {
			if(e.getType() == POLY_EDGE_TYPE) {
				removeEdges.add(e);
			}
		}
		for(Edge e : removeEdges) {
			removeEdge(e);
		}
		
		ArrayList<Node> removeNodes = new ArrayList<Node>();
		for(Node n : getNodes()) {
			if(n.getType() == POLY_NODE_TYPE) {
				removeNodes.add(n);
			}
		}
		for(Node n : removeNodes) {
			removeNode(n);
		}
	}



	/**
	 * Try the to connect disconnected components in a greedy manner,for
	 * each contour choose one of the disconnected components and attempt
	 * to add edges from one of the others. When an edge can be added whilst
	 * maintaining planarity, restart the process with that contour. Edges
	 * are attempted between a pair of nodes with the minimum label difference.
	 */
	public void connectDisconnectedComponents() {
		
		boolean anyChange = false;
		for(String c : findAbstractDiagram().getContours()) {
			boolean modified = true;
			while (modified) {
				modified = connectDisconnectedContour(c);
				if(modified) {
					anyChange = true;
				}
			}
		}
		
		if(anyChange) {
			if(DiagramDrawerPlanar.planarLayout(this)){
			fitInRectangle(50, 50, 400, 400);
			}
		}
	}
	
	
	/**
	 * Attempt to add another connection for the contour.
	 * @return true if a new connection is achieved, otherwise false.
	 */
	public boolean connectDisconnectedContour(String c) {
		
		ArrayList<ArrayList<Node>> incLL = findConnectedSubgraphInc(c);
		ArrayList<ArrayList<Node>> excLL = findConnectedSubgraphExc(c);
		if(incLL.size() <= 1 && excLL.size() <= 1) {
			return false;
		}
		
		Point oldLocation = findCentre();
		
		
		// Do Exc subgraphs
		ArrayList<Node> firstSubgraphInc = incLL.get(0);
		
		ArrayList<Node> remainingSubgraphInc = new ArrayList<Node>();
		for(int i = 1; i < incLL.size(); i++) {
			remainingSubgraphInc.addAll(incLL.get(i));
		}
		
		// First find node pairs with minimum connectivity
		ArrayList<Node[]> nodePairsInc = new ArrayList<Node[]>();
		int minSize = -1;
		
		boolean noEdge = false;
		
		while(!noEdge) {
			noEdge = true;
			int differenceSize = Integer.MAX_VALUE;
			for(Node n1 : firstSubgraphInc) {
				for(Node n2 : remainingSubgraphInc) {
					String label1 = n1.getLabel();
					String label2 = n2.getLabel();
					if(!label1.contains(c) || !label2.contains(c)) {
						// for inc, adding edges only between nodes with the contour in
						continue;
					}
					String diff = DualGraph.findLabelDifferences(label1, label2);
					if(diff.length() <= minSize) {
						// dont want to repeat any edges
						continue;
					}
					
					if(diff.length() <= differenceSize) {
						Node[] pair = new Node[2];
						pair[0] = n1;
						pair[1] = n2;
						if(diff.length() < differenceSize) {
							nodePairsInc = new ArrayList<Node[]>();
							differenceSize = diff.length();
						}
						nodePairsInc.add(pair);
						noEdge = false;
					}
				}
			}
			minSize = differenceSize;
			for(Node[] pair : nodePairsInc) {
				Node n1 = pair[0];
				Node n2 = pair[1];
				Edge connectionEdge = new Edge(n1,n2);
				addEdge(connectionEdge);
				if(DiagramDrawerPlanar.planarLayout(this)) {
					centreOnPoint(oldLocation.x,oldLocation.y);
					return true;
				}
				removeEdge(connectionEdge);
			}
		}

		
		// Do Inc subgraphs
		ArrayList<Node> firstSubgraphExc = excLL.get(0);
		
		ArrayList<Node> remainingSubgraphExc = new ArrayList<Node>();
		for(int i = 1; i < excLL.size(); i++) {
			remainingSubgraphExc.addAll(excLL.get(i));
		}
		
		// First find node pairs with minimum connectivity
		ArrayList<Node[]> nodePairsExc = new ArrayList<Node[]>();
		minSize = -1;
		
		noEdge = false;
		
		while(!noEdge) {
			noEdge = true;
			int differenceSize = Integer.MAX_VALUE;
			for(Node n1 : firstSubgraphExc) {
				for(Node n2 : remainingSubgraphExc) {
					String label1 = n1.getLabel();
					String label2 = n2.getLabel();
					if(label1.contains(c) || label2.contains(c)) {
						// for exc, adding edges only between nodes without the contour in
						continue;
					}
					String diff = DualGraph.findLabelDifferences(label1, label2);
					if(diff.length() <= minSize) {
						// dont want to repeat any edges
						continue;
					}
					
					if(diff.length() <= differenceSize) {
						Node[] pair = new Node[2];
						pair[0] = n1;
						pair[1] = n2;
						if(diff.length() < differenceSize) {
							nodePairsExc = new ArrayList<Node[]>();
							differenceSize = diff.length();
						}
						nodePairsExc.add(pair);
						noEdge = false;
					}
				}
			}
			minSize = differenceSize;
			for(Node[] pair : nodePairsExc) {
				Node n1 = pair[0];
				Node n2 = pair[1];
				Edge connectionEdge = new Edge(n1,n2);
				addEdge(connectionEdge);
				if(DiagramDrawerPlanar.planarLayout(this)) {
					centreOnPoint(oldLocation.x,oldLocation.y);
					return true;
				}
				removeEdge(connectionEdge);
			}
		}


		return false;
		
		
	}


	public ArrayList<CutPoint> findCutPoints() {
		ArrayList<CutPoint> ret = new ArrayList<CutPoint>();
		
		for(TriangulationEdge te : findTriangulationEdges()) {
			ret.addAll(te.getCutPoints());
		}
		for(TriangulationFace tf : getTriangulationFaces()) {
			if(tf.getMeetingPoint() != null) {
				ret.add(tf.getMeetingPoint());
			}
		}
		
		return ret;
	}


	/**
	 * Contour Link connectivity must be assigned before this is called.
	 */
	public ArrayList<ContourLink> findCLsForContour(String contour) {
		TriangulationEdge startTE = firstTriangulationEdgeWithContour(contour);
		if(startTE == null) {
			return null;
		}
		ContourLink startCL = startTE.contourLinksWithContour(contour).get(0);
		ArrayList<ContourLink> ret = new ArrayList<ContourLink>();
		ContourLink cl = null;
		while(startCL != cl) {
			if(cl == null) {
				cl = startCL;
			}
			ret.add(cl);
			cl = cl.getNext();
		}
		return ret;
	}
	
	public static boolean isAtomic(DualGraph dg){
		
		AbstractDiagram ad = dg.findAbstractDiagram();	
		if(ad.generateAtomicDiagrams().countAtomicDiagrams() == 1) {		
			return true;
		}		
		return false;
	}	

	public void optimiseDiagram(DualGraph dg, double maxDis, double minDis){
		
		// ignore the case when the dual graph is not atomic 
		if(DualGraph.isAtomic(dg)){			
			ConcreteDiagram cd = new GeneralConcreteDiagram(dg);
			cd.generateContours();
			ArrayList<ConcreteContour> pl = cd.getConcreteContours();
			for(int i = 0 ; i < pl.size()-1; i++){			
				ConcreteContour cc1 = pl.get(i);
				for(int j = i+1; j< pl.size(); j++){
					ConcreteContour cc2 = pl.get(j);
					double dis = distanceBetweenTwoRegularPolygon(cc1.getPolygon(),cc2.getPolygon());					
					if(dis >  maxDis || dis <  minDis)
					{							
						dg = moveContour(dg, cc1, maxDis, minDis);						
					}				
				}
			}		
		}	
		else{
			System.out.println("optimising graph.....graph is not atomic...");
		}
	}	
	public DualGraph moveContour(DualGraph dg, ConcreteContour cc1, double maxDis, double minDis){		
		
		ConcreteDiagram cd = new GeneralConcreteDiagram(dg);
		cd.generateContours();
		int delta = 0;				
		for(ConcreteContour cc: cd.getConcreteContours()){
			
			Point p1 = getCentre(cc1.getPolygon());				
			//move contours around
			if(cc.getAbstractContour().compareTo(cc1.getAbstractContour())!=0){
				Point p2 = getCentre(cc.getPolygon());				
				double dis = distanceBetweenTwoRegularPolygon(cc.getPolygon(), cc1.getPolygon());					
				
				double sin =p1.getY() - p2.getY()/dis;
				double cos = p1.getX() - p2.getX()/dis;
				double deltaDis = (maxDis - minDis)/10; 
			
				for(int i = 0; i <10; i++){
					
					double deltaX  = cos*deltaDis;
					double deltaY = sin*deltaDis;
					
					cc.getPolygon().translate((int)deltaX, (int)deltaY);
					
					//check if the graph is correct
					boolean correct = false;
					ArrayList<String> duplicateZones = null;
					ArrayList<TriangulationFace> wrongCrossings = null;
					ArrayList<ArrayList<Node>> disconnectedSubGraphs = null;
					try {
						Node articulationNode = dg.findArticulationNode();	
						if(articulationNode != null){
						disconnectedSubGraphs = dg.findDisconnectedSubGraphs(articulationNode);}
						correct = cd.correctConcreteDiagram();
						duplicateZones = cd.findDuplicateZones();
						wrongCrossings = cd.findIncorrectTriangulationCrossings();
					
					} catch(Exception e) {
						e.printStackTrace();
					}
					if(!correct||disconnectedSubGraphs.size() != 0 || duplicateZones.size()!=0 || wrongCrossings.size() != 0 ) {
						cc.getPolygon().translate(-delta, -delta);		
					}
					deltaDis += (maxDis - minDis)/10;
				}
			}
		}				
		return dg;
	}
	
	public double distanceBetweenTwoRegularPolygon(Polygon pol1, Polygon pol2){
		Point p1 = getCentre(pol1);
		Point p2 = getCentre(pol1);	
		return  Math.sqrt((p1.getX()-p2.getX())*(p1.getX()-p2.getX()) 
				+ (p1.getY()-p2.getY())*(p1.getY()-p2.getY()));		
		
	}
	
	public Point getCentre(Polygon p)
	{
	   final Rectangle r = p.getBounds();
	 
	   return new Point(r.x + r.width/2, r.y + r.height/2);
	}
	public double getRadius(Polygon p)
	{
	   final Rectangle r = p.getBounds();
	 
	   return (r.getHeight()/2);
	}
	
	public void checkInductivePiercingDiagram(){
		
		AbstractDiagram ad = this.findAbstractDiagram();
		for(String s : ad.getContours()){
			ArrayList<String> zones = new ArrayList<String>();
			for(String s1: ad.getZoneList()){
				if(s1.contains(s)){
					zones.add(s1);
				}
			}
			if(zones.size()==2){
				String s2 = zones.get(0);
				String s3 = zones.get(1);
				String diff = DualGraph.findLabelDifferences(s2,s3);
				if(diff.length() == 1){
					System.out.println("curvec " + s +" is curve " + diff + " 's piercing"); 
				}
			}
			
			
			
		}
	}
	
}

